Index: nibblerSources/incs/nibbler.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#pragma once\n\n#include <string>\n#include <ostream>\n#include \"IDisplay.hpp\"\n\n#ifndef NIBBLER_ROOT_PROJECT_PATH\n\t#define NIBBLER_ROOT_PROJECT_PATH 0\n#endif\n\n#define SNAKE_MAX 8\n#define SNAKE_MAX_NAME 8\n#define SNAKE_MAX_COLOR 8\n#define CHAT_BUFFER 128\n#define NAME_BUFFER 22\n#define OFFSET 8\n#define SIZEOF_CHAT_PCKT CHAT_BUFFER + NAME_BUFFER + OFFSET\n#define DEFAULT_SIZE_SPRITE 32\n\n#define DIRECTION_VERTICAL 1            // 0000 0001\n#define DIRECTION_HORIZONTAL 4            // 0000 0100\n\n#define MAP_MIN 5\n#define MAP_DEFAULT 30\n#define MAP_MAX 100\n\nenum eTag {\n\tHEAD_TAG = 0,\n\tTAIL_TAG = 8,\n\tFOOD_TAG = 16,\n\tFOOD_TAG_FROM_SNAKE = 32,\n\tWALL_TAG = 64,\n};\n\nenum class eSound {\n\tWELCOME = 0,\n\tREADY = 2,\n\tRESIZE_MAP = 0,\n\tFOOD = 3,\n\tDEATH = 4\n};\n\n\nenum ePriority {\n\tNO_PRIORITY,\n\tMINOR_PRIORITY,\n\tSPECIFIC_LAST,\n};\n\nstruct Snake {\n\tSnake() :\n\n\tsprite(eSprite::BLUE),\n\tisReady(false),\n\tid(-1),\n\tisUpdate(false),\n\tdirection(kNorth),\n\tisAlive(false),\n\tisSwitchingLibrary(false),\n\tisValid(false) {\n\t\tmemset(name, 0, NAME_BUFFER);\n\t};\n\n\tchar name[NAME_BUFFER];\n\teSprite sprite;\n\tbool isReady;\n\tint16_t id;\n\tbool isUpdate;\n\teDirection direction;\n\tbool isAlive;\n\tbool isSwitchingLibrary;\n\tsize_t indexConnection;\n\tbool isValid;\n\tfriend std::ostream &operator<<(std::ostream &os, const Snake &snake);\n\n\tSnake &operator=(Snake const &snake) {\n\t\tif (this != &snake) {\n\t\t\tstd::memcpy(name, snake.name, NAME_BUFFER);\n\t\t\tsprite = snake.sprite;\n\t\t\tisReady = snake.isReady;\n\t\t\tid = snake.id;\n\t\t\tisUpdate = snake.isUpdate;\n\t\t\tdirection = snake.direction;\n\t\t\tisAlive = snake.isAlive;\n\t\t\tisSwitchingLibrary = snake.isSwitchingLibrary;\n\t\t\tindexConnection = snake.indexConnection;\n\t\t\tisValid = snake.isValid;\n\t\t}\n\t\treturn *this;\n\t}\n\n\tstatic Snake randomSnake(int16_t id) {\n\t\tSnake snake;\n\n\t\tsnake.sprite = static_cast<eSprite>(static_cast<int>(eSprite::GREEN) + rand() % SNAKE_MAX_COLOR);\n\t\tstrncpy(snake.name, Snake::basicName[rand() % SNAKE_MAX_NAME].c_str(), NAME_BUFFER);\n\t\tsnake.id = id;\n\t\tsnake.isAlive = true;\n\t\tsnake.isSwitchingLibrary = false;\n\t\tsnake.isValid = true;\n\t\treturn (snake);\n\t}\n\n\tstatic std::string const basicName[SNAKE_MAX_NAME];\n};\n\n//ADD SIZE IN ClientTCP::size_header\n\nenum class eHeader {\n\tCHAT,\n\tFOOD,\n\tID,\n\tOPEN_GAME,\n\tSTART_GAME,\n\tSNAKE,\n\tHEADER,\n\tINPUT,\n\tRESIZE_MAP,\n\tREMOVE_SNAKE,\n\tPOCK,\n\tBORDERLESS,\n\tkPause,\n\tkForcePause\n};\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- nibblerSources/incs/nibbler.hpp	(revision 07b470cbef61f38d4cb872a376d05d61aec26e6d)
+++ nibblerSources/incs/nibbler.hpp	(date 1549557348000)
@@ -32,7 +32,7 @@
 	WALL_TAG = 64,
 };
 
-enum class eSound {
+enum class eNoise {
 	WELCOME = 0,
 	READY = 2,
 	RESIZE_MAP = 0,
Index: nibblerSources/class/gui/widget/WidgetLobby.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"WidgetLobby.hpp\"\n#include <Univers.hpp>\n#include <gui/Core.hpp>\n\nWidgetLobby::WidgetLobby(Core &core) :\n\t\tAWidget(core) {\n\taddColor(eSprite::GREEN, \"Green\", (core_.getPathRessources() / WIDGET_LOBBY_DIRECTORY_SNAKE_PRESENTATION /\n\t\t\t\t\t\t\t\t\t   \"snake_green.png\").generic_string());\n\taddColor(eSprite::BLUE, \"Blue\", (core_.getPathRessources() / WIDGET_LOBBY_DIRECTORY_SNAKE_PRESENTATION /\n\t\t\t\t\t\t\t\t\t \"snake_blue.png\").generic_string());\n\taddColor(eSprite::PURPLE, \"Purple\", (core_.getPathRessources() / WIDGET_LOBBY_DIRECTORY_SNAKE_PRESENTATION /\n\t\t\t\t\t\t\t\t\t\t \"snake_purple.png\").generic_string());\n\taddColor(eSprite::PINK, \"Pink\", (core_.getPathRessources() / WIDGET_LOBBY_DIRECTORY_SNAKE_PRESENTATION /\n\t\t\t\t\t\t\t\t\t \"snake_pink.png\").generic_string());\n\taddColor(eSprite::GREY, \"Grey\", (core_.getPathRessources() / WIDGET_LOBBY_DIRECTORY_SNAKE_PRESENTATION /\n\t\t\t\t\t\t\t\t\t \"snake_grey.png\").generic_string());\n\taddColor(eSprite::YELLOW, \"Yellow\", (core_.getPathRessources() / WIDGET_LOBBY_DIRECTORY_SNAKE_PRESENTATION /\n\t\t\t\t\t\t\t\t\t\t \"snake_yellow.png\").generic_string());\n\taddColor(eSprite::ORANGE, \"Orange\", (core_.getPathRessources() / WIDGET_LOBBY_DIRECTORY_SNAKE_PRESENTATION /\n\t\t\t\t\t\t\t\t\t\t \"snake_orange.png\").generic_string());\n\taddColor(eSprite::RED, \"Red\", (core_.getPathRessources() / WIDGET_LOBBY_DIRECTORY_SNAKE_PRESENTATION /\n\t\t\t\t\t\t\t\t   \"snake_red.png\").generic_string());\n}\n\nvoid WidgetLobby::addColor(eSprite color, std::string const &name, std::string const &pathColor) {\n\tmapSprite_[color].color = color;\n\tmapSprite_[color].name = name;\n\tif (!(mapSprite_[color].sprite.loadFromFile(pathColor)))\n\t\tthrow (AWidget::Constructor(std::string(\"WidgetLobby: Cant load [\") + pathColor + \"]\"));\n}\n\n\nvoid WidgetLobby::addSnake(Snake const &snake, bool isYourSnake) {\n\tif (snakeWidget_.size() < SNAKE_MAX)\n\t\tsnakeWidget_.emplace_back(core_, snake, mapSprite_, isYourSnake);\n}\n\nvoid WidgetLobby::_reload() {\n\tsnakeWidget_.clear();\n\tfor (unsigned int i = 0; i < SNAKE_MAX; i++) {\n\t\tif (core_.univers.getSnakeClient())\n\t\t\taddSnake(snakes_[i], (i == core_.univers.getSnakeClient()->getId_()));\n\t\telse\n\t\t\taddSnake(snakes_[i], false);\n\t}\n}\n\n\nvoid WidgetLobby::render(void) {\n\tsnakes_ = core_.univers.getSnakeArray_();\n\tsf::Vector2<unsigned int> placesForSnakes(4, 2);\n\tsf::Vector2<unsigned int> percentPlaceOfSnake;\n\n\t_reload();\n\tfor (size_t i = 0; i < snakeWidget_.size() && snakes_[i].isValid; i++) {\n\t\tpercentPlaceOfSnake.x = ((100 / placesForSnakes.x) * (i % placesForSnakes.x));\n\t\tpercentPlaceOfSnake.y = ((50 / placesForSnakes.y) * (i / placesForSnakes.x));\n\t\tImGui::SetNextWindowPos(core_.positionByPercent(percentPlaceOfSnake));\n\t\tImGui::SetNextWindowSize(core_.positionByPercent(\n\t\t\t\tsf::Vector2<unsigned int>(100 / placesForSnakes.x, 50 / placesForSnakes.y)));\n\t\tsnakeWidget_[i].render();\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- nibblerSources/class/gui/widget/WidgetLobby.cpp	(revision 07b470cbef61f38d4cb872a376d05d61aec26e6d)
+++ nibblerSources/class/gui/widget/WidgetLobby.cpp	(date 1549551016000)
@@ -38,10 +38,13 @@
 void WidgetLobby::_reload() {
 	snakeWidget_.clear();
 	for (unsigned int i = 0; i < SNAKE_MAX; i++) {
-		if (core_.univers.getSnakeClient())
+		if (core_.univers.getSnakeClient()) {
+
 			addSnake(snakes_[i], (i == core_.univers.getSnakeClient()->getId_()));
-		else
+		}
+		else {
 			addSnake(snakes_[i], false);
+		}
 	}
 }
 
@@ -52,12 +55,15 @@
 	sf::Vector2<unsigned int> percentPlaceOfSnake;
 
 	_reload();
-	for (size_t i = 0; i < snakeWidget_.size() && snakes_[i].isValid; i++) {
-		percentPlaceOfSnake.x = ((100 / placesForSnakes.x) * (i % placesForSnakes.x));
-		percentPlaceOfSnake.y = ((50 / placesForSnakes.y) * (i / placesForSnakes.x));
-		ImGui::SetNextWindowPos(core_.positionByPercent(percentPlaceOfSnake));
-		ImGui::SetNextWindowSize(core_.positionByPercent(
-				sf::Vector2<unsigned int>(100 / placesForSnakes.x, 50 / placesForSnakes.y)));
-		snakeWidget_[i].render();
+
+	for (size_t i = 0; i < snakeWidget_.size(); i++) {
+		if (snakes_[i].isValid) {
+			percentPlaceOfSnake.x = ((100 / placesForSnakes.x) * (i % placesForSnakes.x));
+			percentPlaceOfSnake.y = ((50 / placesForSnakes.y) * (i / placesForSnakes.x));
+			ImGui::SetNextWindowPos(core_.positionByPercent(percentPlaceOfSnake));
+			ImGui::SetNextWindowSize(core_.positionByPercent(
+					sf::Vector2<unsigned int>(100 / placesForSnakes.x, 50 / placesForSnakes.y)));
+			snakeWidget_[i].render();
+		}
 	}
 }
Index: nibblerSources/class/cores/main.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <utility>\n\n\n#include <iostream>\n#include <KINU/Entity.hpp>\n\n#include <KINU/World.hpp>\n\n\n#include <random>\n#include <fstream>\n#include <network/ServerTCP.hpp>\n#include <network/ClientTCP.hpp>\n#include <gui/Core.hpp>\n#include <boost/program_options.hpp>\n#include <logger.h>\n#include <ia/KStar.hpp>\n\nstd::string const Snake::basicName[SNAKE_MAX_NAME] = {\"Jack O'Lantern\", \"Eden\",\n\t\t\t\t\t\t\t\t\t\t\t\t \"Jacky\", \"Emerald\",\n\t\t\t\t\t\t\t\t\t\t\t\t \"Broutille\", \"Veggie-vie\",\n\t\t\t\t\t\t\t\t\t\t\t\t \"jinou42\", \"Dautta c bo\"};\n\nstd::ostream &operator<<(std::ostream &os, const Snake &snake) {\n\tos << \" id: \" << snake.id << \" isReady: \"\n\t   << snake.isReady  << \" isUpdate: \"\n\t   << snake.isUpdate << \" direction: \" << snake.direction << \" isAlive: \"\n\t   << snake.isAlive << \" isSwitchingLibrary: \" << snake.isSwitchingLibrary;\n\treturn os;\n}\n\nvoid nibbler(Univers &univers) {\n\n\n\tboost::filesystem::path pathSound(NIBBLER_ROOT_PROJECT_PATH);\n\tpathSound = pathSound / \"ressouces\" / \"sound\";\n\t\n\tunivers.addNoise((pathSound / \"appear-online.ogg\").generic_string());\n\tunivers.addNoise((pathSound / \"yes-2.wav\").generic_string());\n\tunivers.addNoise((pathSound / \"click.wav\").generic_string());\n\tunivers.addNoise((pathSound / \"slime10.wav\").generic_string());\n\tunivers.addNoise((pathSound / \"hit17.ogg\").generic_string());\n\tunivers.playMusic((pathSound / \"zelda.ogg\").generic_string());\n\twhile (1) {\n\n\t\tunivers.create_ui();\n\t\tunivers.getCore_().aState();\n\n\t\tCore *core = univers.releaseCore_();\n\t\tif (core)\n\t\t\tdelete core;\n\t\tif (univers.isOpenGame_()) {\n//\t\t\tunivers.load_extern_lib_display(Univers::kExternSfmlLibrary);\n\t\t\tunivers.new_game();\n\t\t}\n\t}\n}\n\n\nvoid testKstar() {\n\tint size = 10;\n\n\tKStar kStar;\n\tKStar::Vec2 source(1, 1);\n\tKStar::Vec2 target(9, 9);\n\tkStar.setWorldSize(size);\n\tkStar.setHeuristic(KStar::Heuristic::euclidean);\n\tkStar.setDiagonalMovement(false);\n\n\tint collision[10][10] = {\n\t\t\t{1, 1, 1, 1, 1, 1, 1, 1, 1, 1},\n\t\t\t{1, 0, 0, 0, 0, 1, 1, 0, 0, 1},\n\t\t\t{1, 0, 0, 0, 0, 1, 0, 0, 0, 1},\n\t\t\t{1, 0, 0, 0, 0, 1, 0, 0, 0, 1},\n\t\t\t{1, 0, 0, 0, 0, 1, 0, 0, 0, 1},\n\t\t\t{1, 3, 0, 0, 0, 1, 0, 0, 0, 1},\n\t\t\t{1, 3, 2, 1, 1, 1, 0, 0, 0, 1},\n\t\t\t{1, 0, 0, 0, 0, 0, 0, 0, 0, 1},\n\t\t\t{1, 0, 0, 0, 0, 0, 0, 0, 0, 1},\n\t\t\t{1, 1, 1, 1, 1, 1, 1, 1, 1, 1},\n\t};\n\n\tfor (int y = 0; y < 10; ++y) {\n\t\tfor (int x = 0; x < 10; ++x) {\n\t\t\tif (collision[y][x] == 1)\n\t\t\t\tkStar.addCollision(KStar::Vec2(x, y));\n\t\t\tif (collision[y][x] == 2)\n\t\t\t\tsource = KStar::Vec2(x, y);\n\t\t\tif (collision[y][x] == 3)\n\t\t\t\ttarget = KStar::Vec2(x, y);\n\t\t}\n\n\t}\n\n\tfor (int iy = 0; iy < size; ++iy) {\n\t\tfor (int ix = 0; ix < size; ++ix) {\n\t\t\tif (iy == source.y && ix == source.x)\n\t\t\t\tstd::cout << std::setw(4) << \"_^_\";\n\t\t\telse if (iy == target.y && ix == target.x)\n\t\t\t\tstd::cout << std::setw(4) << \"_O_\";\n\t\t\telse if (kStar.isCollision(KStar::Vec2(ix, iy)))\n\t\t\t\tstd::cout << std::setw(4) << \"_X_\";\n\t\t\telse\n\t\t\t\tstd::cout << std::setw(4) << \"_._\";\n\t\t}\n\t\tstd::cout << std::endl;\n\t}\n\tKStar::Path path = kStar.searchPath(source, target);\n\tstd::cout << std::endl;\n\tstd::cout << path.size() << std::endl;\n\tstd::cout << std::endl;\n\n\tfor (int iy = 0; iy < size; ++iy) {\n\t\tfor (int ix = 0; ix < size; ++ix) {\n\t\t\tif (iy == source.y && ix == source.x)\n\t\t\t\tstd::cout << std::setw(4) << \"_^_\";\n\t\t\telse if (iy == target.y && ix == target.x)\n\t\t\t\tstd::cout << std::setw(4) << \"_O_\";\n\t\t\telse if (kStar.isCollision(KStar::Vec2(ix, iy)))\n\t\t\t\tstd::cout << std::setw(4) << \"_X_\";\n\t\t\telse if (std::find_if(path.begin(), path.end(), [ix, iy](KStar::Vec2 vec){ return vec.x == ix && vec.y == iy; }) != path.end())\n\t\t\t\tstd::cout << std::setw(4) << \"_#_\";\n\t\t\telse\n\t\t\t\tstd::cout << std::setw(4) << \"_._\";\n\t\t}\n\t\tstd::cout << std::endl;\n\t}\n}\n\n//.O\n//\n//\n\nvoid printints(std::array<int, 6> const &ints) {\n\tfor (const auto &item : ints) {\n\t\tstd::cout << item << \" \";\n\t}\n\tstd::cout << std::endl;\n}\nvoid trya() {\n\n\tstd::array<int, 6> ints = {0, 1, 2, 3, 4, 5};\n\tvoid *pVoid = static_cast<void *>(ints.data());\n\tstd::array<int, 6> intsCopy;\n\tstd::cout << \"Print ints initialized\" << std::endl;\n\tprintints(ints);\n\tstd::cout << \"Print ints copy empty\" << std::endl;\n\tprintints(intsCopy);\n\tstd::memcpy(&intsCopy, pVoid, sizeof(ints));\n\tstd::cout << \"Print ints copy full\" << std::endl;\n\tprintints(intsCopy);\n\n}\n\nvoid tryi() {\n\tstd::array<int, 6> connectionsId({ -1, -1, -1, -1, -1, -1 });\n\n\n\tprintints(connectionsId);\n\n\tstd::cout << std::distance(connectionsId.begin(), std::find(connectionsId.begin(), connectionsId.end(), -1)) << std::endl;\n\tconnectionsId[0] = 2;\n\tstd::cout << std::distance(connectionsId.begin(), std::find(connectionsId.begin(), connectionsId.end(), -1)) << std::endl;\n}\n\nint main(int argc, char **argv) {\n//\ttryi();\n//\ttestKstar();\n//\treturn 1;\n\n\tif (!NIBBLER_ROOT_PROJECT_PATH) {\n\t\tstd::cerr << \"NIBBLER_ROOT_PROJECT_PATH is not defined\" << std::endl;\n\t\treturn (0);\n\t}\n\n\tchar hostname[64];\n\tgethostname(hostname, 64);\n\tstd::cout << hostname << std::endl;\n\tsrand(time(NULL));\n\tchar path[] = \"/tmp/log.out\";\n\tif (argc > 1) {\n\t\tlogger_init(argv[1]);\n\t} else {\n\t\tlogger_init(path);\n\t}\n\ttry {\n\t\tUnivers univers;\n\n\t\tboost::program_options::options_description desc(\"Options\");\n\t\tdesc.add_options() // <- Retourne une reference ! OP\n\t\t\t\t(\"help\", \"Print help messages\")\n\t\t\t\t(\"sound\", \"enable the sound\");\n\n\t\tboost::program_options::variables_map vm;\n\t\ttry {\n\t\t\tboost::program_options::store(\n\t\t\t\t\tboost::program_options::parse_command_line(argc, argv,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   desc), vm);\n\n\t\t\tif (vm.count(\"help\")) {\n\t\t\t\tstd::cout << \"Basic Command Line Parameter App\" << std::endl\n\t\t\t\t\t\t  << desc << std::endl;\n\t\t\t\treturn (0);\n\t\t\t}\n\t\t\tif (vm.count(\"sound\")) {\n\t\t\t\tunivers.setFlag(Univers::SOUND);\n\t\t\t}\n\t\t\tboost::program_options::notify(vm);\n\t\t}\n\t\tcatch (const boost::program_options::error &e) {\n\t\t\tstd::cerr << \"ERROR: \" << e.what() << std::endl << std::endl;\n\t\t\tstd::cerr << desc << std::endl;\n\t\t\treturn (0);\n\t\t}\n\t\tnibbler(univers);\n\t}\n\tcatch (const std::exception &e) {\n\t\tstd::cerr << \"Unhandled Exception reached the top of main: \"\n\t\t\t\t  << e.what() << \", application will now exit\" << std::endl;\n\t}\n\tlog_success(\"main.return()\");\n\treturn (0);\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- nibblerSources/class/cores/main.cpp	(revision 07b470cbef61f38d4cb872a376d05d61aec26e6d)
+++ nibblerSources/class/cores/main.cpp	(date 1549558708000)
@@ -33,7 +33,7 @@
 
 
 	boost::filesystem::path pathSound(NIBBLER_ROOT_PROJECT_PATH);
-	pathSound = pathSound / "ressouces" / "sound";
+	pathSound = pathSound / "ressources" / "sound";
 	
 	univers.addNoise((pathSound / "appear-online.ogg").generic_string());
 	univers.addNoise((pathSound / "yes-2.wav").generic_string());
@@ -50,7 +50,7 @@
 		if (core)
 			delete core;
 		if (univers.isOpenGame_()) {
-//			univers.load_extern_lib_display(Univers::kExternSfmlLibrary);
+//			univers.load_extern_lib_display(Univers::kDisplaySfmlLibrary);
 			univers.new_game();
 		}
 	}
@@ -187,7 +187,7 @@
 		Univers univers;
 
 		boost::program_options::options_description desc("Options");
-		desc.add_options() // <- Retourne une reference ! OP
+		desc.add_options()
 				("help", "Print help messages")
 				("sound", "enable the sound");
 
@@ -202,9 +202,8 @@
 						  << desc << std::endl;
 				return (0);
 			}
-			if (vm.count("sound")) {
-				univers.setFlag(Univers::SOUND);
-			}
+			if (vm.count("sound"))
+				univers.load_extern_lib_sound(Univers::eSound::kSoundSfmlLibrary);
 			boost::program_options::notify(vm);
 		}
 		catch (const boost::program_options::error &e) {
Index: nibblerSources/class/network/SnakeClient.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"SnakeClient.hpp\"\n#include <gui/Core.hpp>\n#include <events/FoodCreation.hpp>\n#include <KINU/World.hpp>\n#include <events/StartEvent.hpp>\n#include <Univers.hpp>\n\nSnakeClient::SnakeClient(\n\t\tUnivers &univers,\n\t\tbool fromIA_\n\t\t) :\n\t\tclientTCP_(std::bind(&SnakeClient::callbackDeadConnection, this)),\n\t\tunivers_(univers),\n\t\tfromIA_(fromIA_),\n\t\tid_(0),\n\t\tfactory_(univers) {\n\n\tclientTCP_.addDataType<int16_t >(\n\t\t\tstd::bind(&SnakeClient::callbackRemoveSnake,\n\t\t\t\t\t  this,\n\t\t\t\t\t  std::placeholders::_1)\n\t\t\t, eHeaderK::kRemoveSnake);\n\n\tclientTCP_.addDataType<InputInfo>(\n\t\t\tstd::bind(&SnakeClient::callbackInput,\n\t\t\t\t\t  this,\n\t\t\t\t\t  std::placeholders::_1)\n\t\t\t, eHeaderK::kInput);\n\n\tclientTCP_.addDataType<InputInfo>(\n\t\t\tstd::bind(&SnakeClient::callbackInput,\n\t\t\t\t\t  this,\n\t\t\t\t\t  std::placeholders::_1)\n\t\t\t, eHeaderK::kInput);\n\n\tclientTCP_.addDataType<std::array<Snake, SNAKE_MAX>>(\n\t\t\tstd::bind(&SnakeClient::callbackSnakeArray,\n\t\t\t\t\t  this,\n\t\t\t\t\t  std::placeholders::_1)\n\t\t\t,eHeaderK::kSnakeArray);\n\n\tclientTCP_.addDataType<char>(\n\t\t\tstd::bind(&SnakeClient::callbackPock,\n\t\t\t\t\t  this,\n\t\t\t\t\t  std::placeholders::_1)\n\t\t\t,eHeaderK::kPock);\n\n\tclientTCP_.addDataType<bool>(\n\t\t\tstd::bind(&SnakeClient::callbackBorderless,\n\t\t\t\t\t  this,\n\t\t\t\t\t  std::placeholders::_1)\n\t\t\t,eHeaderK::kBorderless);\n\n\tclientTCP_.addDataType<unsigned int>(\n\t\t\tstd::bind(&SnakeClient::callbackResizeMap,\n\t\t\t\t\t  this,\n\t\t\t\t\t  std::placeholders::_1)\n\t\t\t,eHeaderK::kResizeMap);\n\n\tclientTCP_.addDataType<bool>(\n\t\t\tstd::bind(&SnakeClient::callbackOpenGame,\n\t\t\t\t\t  this,\n\t\t\t\t\t  std::placeholders::_1)\n\t\t\t,eHeaderK::kOpenGame);\n\n\tclientTCP_.addDataType<int16_t>(\n\t\t\tstd::bind(&SnakeClient::callbackId,\n\t\t\t\t\t  this,\n\t\t\t\t\t  std::placeholders::_1)\n\t\t\t,eHeaderK::kId);\n\n\tclientTCP_.addDataType<ChatInfo>(\n\t\t\tstd::bind(&SnakeClient::callbackChatInfo,\n\t\t\t\t\t  this,\n\t\t\t\t\t  std::placeholders::_1)\n\t\t\t,eHeaderK::kChat);\n\n\tclientTCP_.addDataType<StartInfo>(\n\t\t\tstd::bind(&SnakeClient::callbackStartInfo,\n\t\t\t\t\t  this,\n\t\t\t\t\t  std::placeholders::_1)\n\t\t\t,eHeaderK::kStartGame);\n\n\tclientTCP_.addDataType<FoodInfo>(\n\t\t\tstd::bind(&SnakeClient::callbackFood,\n\t\t\t\t\t  this,\n\t\t\t\t\t  std::placeholders::_1)\n\t\t\t,eHeaderK::kFood);\n\n\tclientTCP_.addDataType<Snake>(\n\t\t\tstd::bind(&SnakeClient::callbackSnake,\n\t\t\t\t\t  this,\n\t\t\t\t\t  std::placeholders::_1)\n\t\t\t,eHeaderK::kSnake);\n\n\tclientTCP_.addDataType<int16_t>(\n\t\t\tstd::bind(&SnakeClient::callbackForcePause,\n\t\t\t\t\t  this,\n\t\t\t\t\t  std::placeholders::_1),\n\t\t\teHeaderK::kForcePause);\n\n\tclientTCP_.addDataType<eAction >(\n\t\t\tstd::bind(&SnakeClient::callbackPause,\n\t\t\t\t\t  this,\n\t\t\t\t\t  std::placeholders::_1),\n\t\t\teHeaderK::kPause);\n}\n\nSnakeClient::~SnakeClient() = default;\n\n/***** Network Management *****/\n\n\nvoid SnakeClient::connect(std::string dns, std::string port) {\n\tclientTCP_.connect(dns, port);\n}\n\n\nbool SnakeClient::acceptDataFromServer() const {\n\treturn !fromIA_ || (univers_.isOnlyIA() && univers_.getSnakeClient()->getId_() == id_);\n}\n\nvoid SnakeClient::lock() {\n\tmutex_.lock();\n}\n\nvoid SnakeClient::unlock() {\n\tmutex_.unlock();\n}\n\n/***** Snake Management *****/\n\n\nuint16_t SnakeClient::getId_() const {\n\treturn id_;\n}\n\nbool SnakeClient::allSnakeIsDead() const {\n\treturn std::none_of(snake_array_.begin(), snake_array_.end(),\n\t\t\t[](Snake const &snake){\n\t\t\t\treturn snake.isValid && snake.isAlive;\n\t});\n}\n\nvoid SnakeClient::deliverEvents() {\n\tmutex_.lock();\n\tfor (auto foodCreation : foodCreations) {\n\t\tunivers_.getWorld_().getEventsManager().emitEvent(foodCreation);\n\t}\n\tfoodCreations.clear();\n\tmutex_.unlock();\n}\n\nbool SnakeClient::isSwitchingLibrary() const {\n\treturn snake_array_[id_].isSwitchingLibrary;\n}\n\nconst std::array<Snake, SNAKE_MAX> &SnakeClient::getSnakeArray_() const {\n\treturn snake_array_;\n}\n\nconst Snake &SnakeClient::getSnake() const {\n\tlog_fatal(\"%s %d\", __PRETTY_FUNCTION__, id_);\n\tassert(id_ >= 0 && id_ < SNAKE_MAX);\n\treturn snake_array_[id_];\n}\n\nvoid SnakeClient::changeName(std::string const &name) {\n\tbzero(snake_array_[id_].name, NAME_BUFFER);\n\tif (strlen(name.c_str()) > NAME_BUFFER)\n\t\tstrncpy(snake_array_[id_].name, name.c_str(), NAME_BUFFER - 1);\n\telse\n\t\tstrcpy(snake_array_[id_].name, name.c_str());\n\tsendDataToServer(snake_array_[id_], eHeaderK::kSnake);\n}\n\nvoid SnakeClient::changeMapSize(unsigned int size) {\n\tsendDataToServer(size, eHeaderK::kResizeMap);\n}\n\nbool SnakeClient::allSnakeIsReady() const {\n\treturn std::none_of(snake_array_.begin(), snake_array_.end(),\n\t\t\t\t\t\t\t\t  [](Snake const &snake){\n\t\t\t\t\t\t\t\t\t  return snake.isValid && snake.isReady;\n\t\t\t\t\t\t\t\t  });;\n}\n\nvoid SnakeClient::sendHostOpenGame() {\n//\tsendDataToServer(true, eHeaderK::kOpenGame);\n}\n\nvoid SnakeClient::changeSprite(eSprite snakeSprite) {\n\tsnake_array_[id_].sprite = snakeSprite;\n\n\tsendDataToServer(snake_array_.data()[id_], eHeaderK::kSnake);\n}\n\n\nvoid SnakeClient::changeStateReady(bool change) {\n\tsnake_array_[id_].isReady = change;\n\tsendDataToServer(snake_array_[id_], eHeaderK::kSnake);\n}\n\nvoid SnakeClient::changeIsBorderless(bool borderless) {\n\tsendDataToServer(borderless, eHeaderK::kBorderless);\n}\n\n\nbool SnakeClient::isConnect() const {\n//\tlog_warn(\"%s %d\", __PRETTY_FUNCTION__, clientTCP_.isConnect());\n\treturn clientTCP_.isConnect();\n}\n\nvoid SnakeClient::killSnake(uint16_t id) {\n\tlog_success(\"%s ID : %d C{%d, %d}\", __PRETTY_FUNCTION__, id, id_ == id, fromIA_);\n\tif (id_ == id || (univers_.isIASnake(id) && univers_.isServer())) {\n\t\tsnake_array_[id].isAlive = false;\n\t\tsendDataToServer(snake_array_[id], eHeaderK::kSnake);\n\t}\n\n}\nvoid SnakeClient::removeSnakeFromGame() {\n\tsendDataToServer(id_, eHeaderK::kRemoveSnake);\n}\n\n/***** Callback *****/\n\nvoid SnakeClient::callbackRemoveSnake(int16_t) {\n\n}\n\nvoid SnakeClient::callbackDeadConnection() {\n\tlog_success(\"%s\", __PRETTY_FUNCTION__ );\n\tunivers_.setOpenGame_(false);\n\tclientTCP_.disconnect();\n}\n\nvoid SnakeClient::callbackPock(char) {\n\tlog_success(\"%s %d\", __PRETTY_FUNCTION__, acceptDataFromServer());\n\tmutex_.lock();\n\tif (acceptDataFromServer() && univers_.isOpenGame_()) {\n\t\tunivers_.getWorld_().getEventsManager().emitEvent<NextFrame>();\n\t}\n\tmutex_.unlock();\n}\n\nvoid SnakeClient::callbackResizeMap(unsigned int size) {\n\tlog_success(\"%s\", __PRETTY_FUNCTION__ );\n\tmutex_.lock();\n\tif (acceptDataFromServer()) {\n\t\tunivers_.setMapSize(size);\n\t\tunivers_.playNoise(eSound::RESIZE_MAP);\n\t}\n\tmutex_.unlock();\n}\n\nvoid SnakeClient::callbackOpenGame(bool open) {\n\tlog_success(\"%s\", __PRETTY_FUNCTION__ );\n\tmutex_.lock();\n\tif (acceptDataFromServer()) {\n\t\tunivers_.setOpenGame_(open);\n\t}\n\tmutex_.unlock();\n}\n\nvoid SnakeClient::callbackBorderless(bool borderless) {\n\tlog_success(\"%s\", __PRETTY_FUNCTION__ );\n\tmutex_.lock();\n\tif (acceptDataFromServer()) {\n\t\tunivers_.setBorderless(borderless);\n\t}\n\tmutex_.unlock();\n}\n\nvoid SnakeClient::callbackId(int16_t id) {\n\tlog_success(\"%s id : %d\", __PRETTY_FUNCTION__ , id);\n\tmutex_.lock();\n\tid_ = id;\n\tif (fromIA_) {\n\t\tchangeStateReady(true);\n\t}\n\tmutex_.unlock();\n}\n\nvoid SnakeClient::callbackInput(InputInfo) {\n\tlog_success(\"%s\", __PRETTY_FUNCTION__ );\n\n}\n\nvoid SnakeClient::callbackForcePause(int16_t) {\n\tlog_success(\"%s\", __PRETTY_FUNCTION__ );\n\n}\n\nvoid SnakeClient::callbackPause(eAction) {\n\tlog_success(\"%s\", __PRETTY_FUNCTION__ );\n\tmutex_.lock();\n\tunivers_.refreshTimerLoopWorld();\n\tmutex_.unlock();\n}\n\nvoid SnakeClient::callbackSnake(Snake snake) {\n\tlog_success(\"%s\", __PRETTY_FUNCTION__ );\n\tmutex_.lock();\n\tsnake_array_[snake.id] = snake;\n\tif (acceptDataFromServer()) {\n\t\tunivers_.playNoise(eSound::READY);\n\t}\n\tmutex_.unlock();\n}\n\nvoid SnakeClient::callbackFood(FoodInfo foodInfo) {\n\tlog_success(\"%s\", __PRETTY_FUNCTION__ );\n\tmutex_.lock();\n\tif (acceptDataFromServer()) {\n\t\tfoodCreations.push_back(\n\t\t\t\tFoodCreation(foodInfo.positionComponent,foodInfo.fromSnake));\n\t}\n\tmutex_.unlock();\n}\n\nvoid SnakeClient::callbackStartInfo(StartInfo startInfo) {\n\tlog_success(\"%s\", __PRETTY_FUNCTION__ );\n\tmutex_.lock();\n\tfoodCreations.clear();\n\tif (acceptDataFromServer()) {\n\t\tfactory_.create_all_snake(snake_array_, startInfo.nu);\n\t\tif (univers_.isServer()) {\n\t\t\tint max_food = (startInfo.nu > 1 ? startInfo.nu - 1 : startInfo.nu);\n\t\t\tfor (int index = 0; index < max_food; ++index) {\n\t\t\t\tclientTCP_.writeDataToServer(\n\t\t\t\t\t\tFoodInfo(\n\t\t\t\t\t\t\t\tPositionComponent(\n\t\t\t\t\t\t\t\t\t\tunivers_.getGrid_().getRandomSlot(eSprite::NONE)),false),\n\t\t\t\t\t\t\t\t\t\tstatic_cast<uint16_t>(eHeaderK::kFood)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tunivers_.getWorld_().getEventsManager().emitEvent<StartEvent>(startInfo.time_duration);\n\t}\n\tmutex_.unlock();\n}\n\nvoid SnakeClient::callbackChatInfo(ChatInfo chatInfo) {\n\tlog_success(\"%s\", __PRETTY_FUNCTION__ );\n\tmutex_.lock();\n\tif (acceptDataFromServer()) {\n\t\tunivers_.getCore_().addMessageChat(chatInfo.toString());\n\t}\n\tmutex_.unlock();\n}\n\nvoid SnakeClient::callbackSnakeArray(std::array<Snake, SNAKE_MAX> new_snake_array) {\n\tlog_success(\"%s\", __PRETTY_FUNCTION__ );\n\tmutex_.lock();\n\tsnake_array_ = new_snake_array;\n\tmutex_.unlock();\n}\n\nbool SnakeClient::isReady() const {\n\treturn snake_array_[id_].isReady;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- nibblerSources/class/network/SnakeClient.cpp	(revision 07b470cbef61f38d4cb872a376d05d61aec26e6d)
+++ nibblerSources/class/network/SnakeClient.cpp	(date 1549557413000)
@@ -249,7 +249,7 @@
 	mutex_.lock();
 	if (acceptDataFromServer()) {
 		univers_.setMapSize(size);
-		univers_.playNoise(eSound::RESIZE_MAP);
+		univers_.playNoise(eNoise::RESIZE_MAP);
 	}
 	mutex_.unlock();
 }
@@ -304,7 +304,7 @@
 	mutex_.lock();
 	snake_array_[snake.id] = snake;
 	if (acceptDataFromServer()) {
-		univers_.playNoise(eSound::READY);
+		univers_.playNoise(eNoise::READY);
 	}
 	mutex_.unlock();
 }
Index: work.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[ 19:50:05 ] (l.376) Univers.cpp          -> 1\n[ 19:50:05 ] (l. 47) ServerTCP.cpp        -> New id on server 0\n[ 19:50:05 ] (l.166) ClientTCP.cpp        -> eHeader::ID 0\n[ 19:50:05 ] (l.214) ClientTCP.cpp        -> eHeader::RESIZE_MAP\n[ 19:50:05 ] (l.470) Univers.cpp          -> New map size [30]\n[ 19:50:06 ] (l. 45) ClientTCP.cpp        -> Close clientTCP\n[ 19:50:08 ] (l. 17) ServerTCP.cpp        -> ~ServerTCP::pointers.clear()\n[ 19:50:08 ] (l. 19) ServerTCP.cpp        -> ~ServerTCP::io_service_.stop()\n[ 19:50:08 ] (l. 21) ServerTCP.cpp        -> ~ServerTCP::acceptor_.cancel()\n[ 19:50:08 ] (l. 23) ServerTCP.cpp        -> ~ServerTCP::acceptor_.close()\n[ 19:50:08 ] (l. 25) ServerTCP.cpp        -> ~ServerTCP::thread.interrupt()\n[ 19:50:08 ] (l. 27) ServerTCP.cpp        -> ~ServerTCP::end()\n[ 19:50:13 ] (l.543) Univers.cpp          -> ~Univers\n[ 19:50:13 ] (l.545) Univers.cpp          -> ~Univers::clientTCP_::destroy\n[ 19:50:14 ] (l.548) Univers.cpp          -> ~Univers::serverTCP_ ::destroy\n[ 19:50:14 ] (l.121) Univers.cpp          -> Univers::unload_external_library\n[ 19:50:14 ] (l.133) Univers.cpp          -> Univers::unload_external_library.unlock()\n[ 19:50:14 ] (l.553) Univers.cpp          -> ~Univers.end()\n[ 19:50:14 ] (l.183) main.cpp             -> main.return()\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- work.txt	(revision 07b470cbef61f38d4cb872a376d05d61aec26e6d)
+++ work.txt	(date 1549554528000)
@@ -14,6 +14,6 @@
 [ 19:50:13 ] (l.545) Univers.cpp          -> ~Univers::clientTCP_::destroy
 [ 19:50:14 ] (l.548) Univers.cpp          -> ~Univers::serverTCP_ ::destroy
 [ 19:50:14 ] (l.121) Univers.cpp          -> Univers::unload_external_library
-[ 19:50:14 ] (l.133) Univers.cpp          -> Univers::unload_external_library.unlock()
+[ 19:50:14 ] (l.133) Univers.cpp          -> Univers::unload_external_display_library.unlock()
 [ 19:50:14 ] (l.553) Univers.cpp          -> ~Univers.end()
 [ 19:50:14 ] (l.183) main.cpp             -> main.return()
Index: nibblerSources/class/systems/CollisionSystem.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"CollisionSystem.hpp\"\n#include <factory/Factory.hpp>\n#include <events/FoodEat.hpp>\n#include <network/ClientTCP.hpp>\n#include <logger.h>\n#include <MutantGrid.tpp>\n#include <component/CollisionComponent.hpp>\n#include <KINU/Entity.hpp>\n#include <KINU/World.hpp>\n#include <network/Data.hpp>\n#include <network/SnakeClient.hpp>\n\n\nCollisionSystem::CollisionSystem(Univers &univers) : univers_(univers) {\n\trequireComponent<CollisionComponent>();\n\trequireComponent<PositionComponent>();\n}\n\n\nvoid CollisionSystem::checkCollision(\n\t\tKINU::Entity entityHead, KINU::Entity entityCheck) {\n\n\tauto &snakePositionComponent = entityHead.getComponent<PositionComponent>();\n\tauto &positionComponent = entityCheck.getComponent<PositionComponent>();\n\n\tif (snakePositionComponent == positionComponent &&\n\t\tentityHead != entityCheck && entityCheck.hasGroupId() && entityHead.hasGroupId()) {\n\t\tKINU::TagId tagId = entityCheck.getGroupIdByEntity();\n\t\tlog_info(\"CollisionSystem\");\n\n\t\tif (tagId == eTag::FOOD_TAG) {\n\t\t\tlog_info(\"FOOD_TAG::FoodCollision\");\n\t\t\tunivers_.playNoise(eSound::FOOD);\n\t\t\tentityCheck.kill();\n\t\t\tgetWorld().getEventsManager().emitEvent<FoodEat>(entityHead.getGroupIdByEntity());\n\n\t\t\tif (univers_.getSnakeClient()->getId_() == entityHead.getGroupIdByEntity() ||\n\t\t\t\tunivers_.isIASnake(entityHead.getGroupIdByEntity())) {\n\n\t\t\t\tunivers_.getSnakeClient()->sendDataToServer(\n\t\t\t\t\t\tFoodInfo(PositionComponent(\n\t\t\t\t\t\t\t\tunivers_.getGrid_().getRandomSlot(eSprite::NONE)),\n\t\t\t\t\t\t\t\t\t\tfalse),\n\t\t\t\t\t\t\t\t\t\teHeaderK::kFood);\n\t\t\t}\n\t\t} else if (tagId == eTag::FOOD_TAG_FROM_SNAKE) {\n\t\t\tunivers_.playNoise(eSound::FOOD);\n\t\t\tentityCheck.kill();\n\t\t\tif (entityHead.hasGroupId())\n\t\t\t\tgetWorld().getEventsManager().emitEvent<FoodEat>(entityHead.getGroupIdByEntity());\n\t\t} else if (tagId == WALL_TAG) {\n\t\t\tcreateAppleBySnake(entityHead);\n\t\t\tunivers_.getSnakeClient()->killSnake(entityHead.getGroupIdByEntity());\n\t\t\tentityHead.killGroup();\n\t\t} else if (entityCheck.getGroupIdByEntity() == entityHead.getGroupIdByEntity()) {\n\t\t\tcreateAppleBySnake(entityHead);\n\t\t\tunivers_.getSnakeClient()->killSnake(entityHead.getGroupIdByEntity());\n\t\t\tentityHead.killGroup();\n\t\t} else {\n\t\t\tcreateAppleBySnake(entityHead);\n\t\t\tunivers_.getSnakeClient()->killSnake(entityHead.getGroupIdByEntity());\n\t\t\tentityHead.killGroup();\n\t\t}\n\n\t}\n}\n\nvoid CollisionSystem::update() {\n\tstd::vector<KINU::Entity> entities_ = getEntities();\n\tfor (auto entity : getEntities()) {\n\t\tif (entity.hasTagId() &&\n\t\t\tentity.getTagId() - entity.getGroupIdByEntity() == eTag::HEAD_TAG) {\n\t\t\tfor (auto entityCheck : entities_) {\n\t\t\t\tcheckCollision(entity, entityCheck);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CollisionSystem::createAppleBySnake(KINU::Entity snake) {\n\n\tauto appleSnake = getWorld().getEntitiesManager().getEntitiesByGroupId(snake.getGroupIdByEntity());\n\tauto positionHead = snake.getComponent<PositionComponent>();\n\tfor (auto snakeCheck : appleSnake) {\n\t\tif (snakeCheck.hasComponent<PositionComponent>()) {\n\t\t\tauto positionComponent = snakeCheck.getComponent<PositionComponent>();\n\t\t\tif (positionComponent != positionHead) {\n\t\t\t\tunivers_.getSnakeClient()->sendDataToServer(\n\t\t\t\t\t\tFoodInfo(positionComponent, true), eHeaderK::kFood);\n\t\t\t}\n\t\t}\n\t}\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- nibblerSources/class/systems/CollisionSystem.cpp	(revision 07b470cbef61f38d4cb872a376d05d61aec26e6d)
+++ nibblerSources/class/systems/CollisionSystem.cpp	(date 1549557413000)
@@ -30,7 +30,7 @@
 
 		if (tagId == eTag::FOOD_TAG) {
 			log_info("FOOD_TAG::FoodCollision");
-			univers_.playNoise(eSound::FOOD);
+			univers_.playNoise(eNoise::FOOD);
 			entityCheck.kill();
 			getWorld().getEventsManager().emitEvent<FoodEat>(entityHead.getGroupIdByEntity());
 
@@ -44,7 +44,7 @@
 										eHeaderK::kFood);
 			}
 		} else if (tagId == eTag::FOOD_TAG_FROM_SNAKE) {
-			univers_.playNoise(eSound::FOOD);
+			univers_.playNoise(eNoise::FOOD);
 			entityCheck.kill();
 			if (entityHead.hasGroupId())
 				getWorld().getEventsManager().emitEvent<FoodEat>(entityHead.getGroupIdByEntity());
Index: nibblerSources/class/network/ClientTCP.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include <logger.h>\n#include <cstdlib>\n#include <deque>\n#include <iostream>\n#include <nibbler.hpp>\n#include <boost/asio.hpp>\n#include <Univers.hpp>\n#include \"ClientTCP.hpp\"\n#include <gui/Core.hpp>\n#include <exception>\n#include <events/NextFrame.hpp>\n#include <KINU/World.hpp>\n#include <events/FoodCreation.hpp>\n#include <events/StartEvent.hpp>\n#include <systems/RenderSystem.hpp>\n#include <network/Data.hpp>\nint const ClientTCP::size_header[] = {\n\t\t[static_cast<int>(eHeader::CHAT)] = SIZEOF_CHAT_PCKT,\n\t\t[static_cast<int>(eHeader::FOOD)] = sizeof(FoodInfo),\n\t\t[static_cast<int>(eHeader::ID)] = sizeof(int16_t),\n\t\t[static_cast<int>(eHeader::OPEN_GAME)] = sizeof(bool),\n\t\t[static_cast<int>(eHeader::START_GAME)] = sizeof(StartInfo),\n\t\t[static_cast<int>(eHeader::SNAKE)] = sizeof(Snake),\n\t\t[static_cast<int>(eHeader::HEADER)] = sizeof(eHeader),\n\t\t[static_cast<int>(eHeader::INPUT)] = sizeof(InputInfo),\n\t\t[static_cast<int>(eHeader::RESIZE_MAP)] = sizeof(unsigned int),\n\t\t[static_cast<int>(eHeader::REMOVE_SNAKE)] = sizeof(int16_t),\n\t\t[static_cast<int>(eHeader::POCK)] = sizeof(char),\n\t\t[static_cast<int>(eHeader::BORDERLESS)] = sizeof(bool),\n\t\t[static_cast<int>(eHeader::kPause)] = sizeof(eAction),\n\t\t[static_cast<int>(eHeader::kForcePause)] = sizeof(int16_t)\n};\n\nClientTCP::ClientTCP(Univers &univers, bool fromIA)\n\t\t: fromIA_(fromIA),\n\t\t  openGame_(false),\n\t\t  id_(0),\n\t\t  univers(univers),\n\t\t  resolver(io),\n\t\t  socket(io),\n\t\t  factory(univers) {\n}\n\nClientTCP::~ClientTCP() {\n\ttry {\n\t\tif (socket.is_open()) {\n\t\t\tsocket.shutdown(boost::asio::ip::tcp::socket::shutdown_both);\n\t\t\tsocket.close();\n\t\t}\n\t} catch (std::exception const &e) {\n\t\tstd::cout << e.what() << std::endl;\n\t}\n\n\tthread.interrupt();\n\tio.stop();\n\tlog_error(\"Close clientTCP\");\n}\n\n/** Network Management **/\n\nvoid ClientTCP::connect(std::string dns, std::string port) {\n\ttry {\n\t\ttcp::resolver::query query(dns, port);\n\t\ttcp::resolver::iterator it = resolver.resolve(query);\n\t\tboost::asio::connect(socket, it);\n\t\tread_socket_header();\n\t\tthread = boost::thread(boost::bind(&boost::asio::io_service::run, &io));\n\t\tthread.detach();\n\t\tdns_ = dns;\n\t\tport_ = port;\n\t} catch (std::exception &exception) {\n\t\tstd::cout << exception.what() << std::endl;\n\t}\n\n}\n\nvoid ClientTCP::checkError_(boost::system::error_code const &error_code) {\n\n\tif ((boost::asio::error::eof == error_code) ||\n\t\t(boost::asio::error::connection_reset == error_code))\n\t{\n\t\tthread.interrupt();\n\t\tsocket.close();\n\t\tio.stop();\n//\t\tthrow std::runtime_error(\"Lost signal from server\");\n\t}\n}\n\n\nvoid ClientTCP::read_socket_header() {\n\tboost::asio::async_read(socket, boost::asio::buffer(buffer_data,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tClientTCP::size_header[static_cast<int>(eHeader::HEADER)]),\n\t\t\t\t\t\t\tboost::bind(&ClientTCP::handle_read_header,\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tboost::asio::placeholders::error,\n\t\t\t\t\t\t\t\t\t\tboost::asio::placeholders::bytes_transferred));\n}\n\nvoid ClientTCP::read_socket_data(eHeader header) {\n\tboost::asio::async_read(socket, boost::asio::buffer(buffer_data,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tClientTCP::size_header[static_cast<int>(header)]),\n\t\t\t\t\t\t\tboost::bind(&ClientTCP::handle_read_data,\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\theader,\n\t\t\t\t\t\t\t\t\t\tboost::asio::placeholders::error,\n\t\t\t\t\t\t\t\t\t\tboost::asio::placeholders::bytes_transferred));\n}\n\nvoid ClientTCP::handle_read_header(const boost::system::error_code &error_code,\n\t\t\t\t\t\t\t\t   size_t len) {\n\n\tcheckError_(error_code);\n\n\tif (error_code.value() == 0) {\n\t\tassert(len == sizeof(eHeader));\n\t\teHeader header;\n\t\tstd::memcpy(&header, buffer_data.data(), sizeof(eHeader));\n\t\tread_socket_data(header);\n\t}\n}\n\nvoid ClientTCP::parse_input(eHeader header, void const *input, size_t len) {\n\tmutex.lock();\n\tswitch (header) {\n\t\tcase eHeader::CHAT: {\n\t\t\tif (accept_data()) {\n\n\t\t\t\tchar *data_deserialize = new char[len];\n\t\t\t\tstd::memcpy(data_deserialize, input, len);\n\t\t\t\tunivers.getCore_().addMessageChat(\n\t\t\t\t\t\tstd::string(data_deserialize, len));\n\t\t\t\tdelete[] data_deserialize;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase eHeader::SNAKE: {\n\t\t\tSnake snake_temp;\n\t\t\tstd::memcpy(&snake_temp, input, len);\n\t\t\tlog_info(\"eHeader::SNAKE f.%d w.%d %d\", getId(),  snake_temp.id, snake_temp.isAlive);\n\t\t\tsnake_array_[snake_temp.id] = snake_temp;\n\t\t\tif (accept_data()) {\n\t\t\t\tunivers.playNoise(eSound::READY);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase eHeader::REMOVE_SNAKE: {\n\t\t\tlog_info(\"eHeader::REMOVE_SNAKE\");\n\t\t\tsnake_array_[*(reinterpret_cast< const int16_t *>(input))].reset();\n\t\t\tunivers.playNoise(eSound::DEATH);\n\t\t\tbreak;\n\t\t}\n\t\tcase eHeader::FOOD: {\n\t\t\tlog_info(\"eHeader::FOOD\");\n\t\t\tif (accept_data()) {\n\n\t\t\t\tFoodInfo foodInfo;\n\t\t\t\tstd::memcpy(&foodInfo, input, len);\n\t\t\t\tfoodCreations.push_back(FoodCreation(foodInfo.positionComponent,\n\t\t\t\t\t\t\t\t\t\t\t\t\t foodInfo.fromSnake));\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase eHeader::ID: {\n\t\t\tstd::memcpy(&id_, input, len);\n\t\t\tsnake_array_[id_].id = id_;\n\t\t\tlog_info(\"eHeader::ID %d\", id_);\n\t\t\tbreak;\n\t\t}\n\t\tcase eHeader::OPEN_GAME: {\n\t\t\tlog_info(\"eHeader::OPEN_GAME\");\n\t\t\tif (accept_data()) {\n\t\t\t\tStartInfo startInfo;\n\t\t\t\tbool data;\n\t\t\t\tstd::memcpy(&data, input,\n\t\t\t\t\t\t\tClientTCP::size_header[static_cast<int>(eHeader::OPEN_GAME)]);\n\t\t\t\topenGame_ = data;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase eHeader::START_GAME: {\n\t\t\tlog_info(\"eHeader::START_GAME : %d\", fromIA_);\n\t\t\tif (accept_data()) {\n\t\t\t\tStartInfo st;\n\t\t\t\tstd::memcpy(&st, input,\n\t\t\t\t\t\t\tClientTCP::size_header[static_cast<int>(eHeader::START_GAME)]);\n\t\t\t\tfactory.create_all_snake(snake_array_, st.nu);\n\n\t\t\t\tif (univers.isServer()) {\n\n\t\t\t\t\tuint16_t  nu_ = std::count_if(snake_array_.begin(), snake_array_.end(), [](auto snake){ return snake.isValid;});\n\t\t\t\t\tint max_food = (nu_ > 1 ? nu_ - 1 : nu_);\n\t\t\t\t\tlog_warn(\"Number of food %d\", max_food);\n\n\t\t\t\t\tfor (int index = 0; index < max_food; ++index) {\n\t\t\t\t\t\tFoodInfo foodInfo(\n\t\t\t\t\t\t\t\tPositionComponent(univers.getWorld_()\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  .grid.getRandomSlot(eSprite::NONE))\n\t\t\t\t\t\t\t\t, false);\n\t\t\t\t\t\twrite_socket(ClientTCP::add_prefix(eHeader::FOOD, &foodInfo));\n\t\t\t\t\t}\n\n\t\t\t\t\tunivers.getWorld_().getEventsManager().emitEvent<StartEvent>(\n\t\t\t\t\t\t\tst.time_duration);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase eHeader::INPUT: {\n\t\t\tbreak;\n\t\t}\n\t\tcase eHeader::RESIZE_MAP: {\n\t\t\tif (accept_data()) {\n\t\t\t\tlog_info(\"eHeader::ConditionRESIZE_MAP\");\n\t\t\t\tunsigned int buffer;\n\t\t\t\tstd::memcpy(&buffer, input,\n\t\t\t\t\t\t\tClientTCP::size_header[static_cast<int>(eHeader::RESIZE_MAP)]);\n\t\t\t\tunivers.setMapSize(buffer);\n\t\t\t\tunivers.playNoise(eSound::RESIZE_MAP);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase eHeader::BORDERLESS : {\n\t\t\tif (accept_data()) {\n\t\t\t\tbool borderless;\n\t\t\t\tstd::memcpy(&borderless, input,\n\t\t\t\t\t\t\tClientTCP::size_header[static_cast<int>(eHeader::BORDERLESS)]);\n\t\t\t\tunivers.setBorderless(borderless);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase eHeader::POCK: {\n\t\t\tlog_warn(\"eHeader::POCK\");\n\t\t\tif (accept_data()) {\n\t\t\t\tunivers.getWorld_().getEventsManager().emitEvent<NextFrame>();\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase eHeader::kPause : {\n\t\t\tunivers.refreshTimerLoopWorld();\n\t\t}\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\tmutex.unlock();\n}\n\n\n\nvoid ClientTCP::write_socket(std::string message) {\n\tboost::asio::async_write(socket, boost::asio::buffer(message),\n\t\t\t\t\t\t\t boost::bind(&ClientTCP::handle_write,\n\t\t\t\t\t\t\t\t\t\t this,\n\t\t\t\t\t\t\t\t\t\t boost::asio::placeholders::error,\n\t\t\t\t\t\t\t\t\t\t boost::asio::placeholders::bytes_transferred));\n}\nvoid ClientTCP::handle_read_data(eHeader header, boost::system::error_code const &error_code,\n\t\t\t\t\t\t\t\t size_t len) {\n\tcheckError_(error_code);\n\tif (error_code.value() == 0 && len > 0) {\n\t\tparse_input(header, buffer_data.data(), len);\n\t}\n\tread_socket_header();\n}\n\nvoid ClientTCP::handle_write(const boost::system::error_code &error_code,\n\t\t\t\t\t\t\t size_t) {\n\tcheckError_(error_code);\n}\n\nconst std::string &ClientTCP::getDns() const {\n\treturn dns_;\n}\n\nconst std::string &ClientTCP::getPort() const {\n\treturn port_;\n}\n\n/** Game Management **/\n\nvoid ClientTCP::addScore(uint16_t score) {\n}\n\nvoid ClientTCP::send_host_open_game(void) {\n\tbool data;\n\tdata = true;\n\twrite_socket(add_prefix(eHeader::OPEN_GAME, &data));\n}\n\nvoid ClientTCP::change_map_size(unsigned int size) {\n\twrite_socket(add_prefix(eHeader::RESIZE_MAP, &size));\n}\n\nvoid ClientTCP::change_name(char const *name) {\n\tbzero(snake_array_[id_].name, NAME_BUFFER);\n\tif (strlen(name) > NAME_BUFFER)\n\t\tstrncpy(snake_array_[id_].name, name, NAME_BUFFER - 1);\n\telse\n\t\tstrcpy(snake_array_[id_].name, name);\n\trefreshMySnake();\n}\n\nvoid ClientTCP::change_sprite(eSprite snakeSprite) {\n\tsnake_array_[id_].sprite = snakeSprite;\n\trefreshMySnake();\n}\n\nvoid ClientTCP::change_state_ready(void) {\n\tsnake_array_[id_].isReady = !snake_array_[id_].isReady;\n\trefreshMySnake();\n}\n\nvoid ClientTCP::refreshMySnake(void) {\n\twrite_socket(add_prefix(eHeader::SNAKE, &snake_array_[id_]));\n}\n\nint16_t ClientTCP::getId() const {\n\treturn id_;\n}\n\nbool\tClientTCP::isConnect() const {\n\treturn socket.is_open();\n}\n\nbool\tClientTCP::isOpenGame() const {\n\treturn openGame_;\n}\n\nvoid ClientTCP::deliverEvents() {\n\tmutex.lock();\n\tfor (auto foodCreation : foodCreations) {\n\t\tunivers.getWorld_().getEventsManager().emitEvent(foodCreation);\n\t}\n\tfoodCreations.clear();\n\tmutex.unlock();\n}\n\nSnake\tconst &ClientTCP::getSnake(void) const {\n\treturn snake_array_[id_];\n}\n\nconst Snake *ClientTCP::getSnakes() const {\n\treturn snake_array_.data();\n}\n\nvoid ClientTCP::killSnake(uint16_t id) {\n\tlog_warn(\"ClientTCP::killSnake. %d\", id);\n\tsnake_array_[id].isAlive = false;\n\twrite_socket(add_prefix(eHeader::SNAKE, &snake_array_[id]));\n}\n\nvoid ClientTCP::send_borderless(bool borderless) {\n\twrite_socket(ClientTCP::add_prefix(eHeader::BORDERLESS, &borderless));\n}\n\nbool ClientTCP::all_snake_is_dead() {\n\tfor (auto &snake : snake_array_) {\n\t\tif (snake.id != -1 && snake.isAlive)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\n/** Mutex Management **/\n\nvoid ClientTCP::lock() {\n\tmutex.lock();\n}\n\nvoid ClientTCP::unlock() {\n\tmutex.unlock();\n}\n\nbool ClientTCP::accept_data() {\n\treturn !fromIA_ || (univers.isOnlyIA() && id_ == 0);\n}\n\nbool ClientTCP::isSwitchingLibrary() const {\n\treturn snake_array_[id_].isSwitchingLibrary;\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- nibblerSources/class/network/ClientTCP.cpp	(revision 07b470cbef61f38d4cb872a376d05d61aec26e6d)
+++ nibblerSources/class/network/ClientTCP.cpp	(date 1549557413000)
@@ -139,14 +139,14 @@
 			log_info("eHeader::SNAKE f.%d w.%d %d", getId(),  snake_temp.id, snake_temp.isAlive);
 			snake_array_[snake_temp.id] = snake_temp;
 			if (accept_data()) {
-				univers.playNoise(eSound::READY);
+				univers.playNoise(eNoise::READY);
 			}
 			break;
 		}
 		case eHeader::REMOVE_SNAKE: {
 			log_info("eHeader::REMOVE_SNAKE");
 			snake_array_[*(reinterpret_cast< const int16_t *>(input))].reset();
-			univers.playNoise(eSound::DEATH);
+			univers.playNoise(eNoise::DEATH);
 			break;
 		}
 		case eHeader::FOOD: {
Index: nibblerSources/incs/IDisplay.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#pragma once\n\n#include <MutantGrid.tpp>\n#include <Sprite.hpp>\n\n#define SPRITE_GROUND 8 * SIZE_LINE_TILESET\n#define SPRITE_WALL 8 * SIZE_LINE_TILESET + 1\n#define SPRITE_FOOD SIZE_LINE_TILESET\n#define PATH_TILESET \"snake_tileset.png\"\n#define SIZE_LINE_TILESET 15\n\n#define MUSIC_ZELDA \"sound/zelda.ogg\"\n\n#define DISPLAY_DEFAULT_TILESET_PATH \"snake_tileset.png\"\n#define DISPLAY_DEFAULT_TILE_SIZE 32\n\n\nenum eDirection {\n\tkNorth = 1,\t\t\t\t\t\t\t// 0000 0001\n\tkSouth = 3,\t\t\t\t\t\t\t// 0000 0011\n\tkEast = 4,\t\t\t\t\t\t\t// 0000 0100\n\tkWest = 12\t\t\t\t\t\t\t// 0000 1100\n};\n\nenum eAction {\n\tkPause,\n\tkSwitchDisplayLibrary,\n\tkCreateClient,\n\tkDeleteClient,\n\tkCreateServer,\n\tkDeleteServer,\n\tkCreateIA,\n\tkDeleteIA,\n\tkConnect,\n\tkBorderless,\n\tkStartGame,\n\tkReady\n\n};\n\nclass IDisplay {\npublic:\n\n\tvirtual ~IDisplay() {}\n\n\tvirtual bool exit(void) const = 0;\n\n\tvirtual void render(float currentDelayFrame, float maxDelayFrame) = 0;\n\n\tvirtual void update(float deltaTime) = 0;\n\n\tvirtual void drawGrid(MutantGrid<eSprite> const &grid) = 0;\n\n\tvirtual void setBackground(MutantGrid<eSprite> const &grid) = 0;\n\n\tvirtual eDirection getDirection(void) const = 0;\n\n\tvirtual void registerCallbackAction(std::function<void(eAction)>) = 0;\n};\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- nibblerSources/incs/IDisplay.hpp	(revision 07b470cbef61f38d4cb872a376d05d61aec26e6d)
+++ nibblerSources/incs/IDisplay.hpp	(date 1549558905000)
@@ -9,8 +9,6 @@
 #define PATH_TILESET "snake_tileset.png"
 #define SIZE_LINE_TILESET 15
 
-#define MUSIC_ZELDA "sound/zelda.ogg"
-
 #define DISPLAY_DEFAULT_TILESET_PATH "snake_tileset.png"
 #define DISPLAY_DEFAULT_TILE_SIZE 32
 
Index: nibblerSources/class/Univers.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#pragma once\n\n#include <ia/Bobby.hpp>\n#include <memory>\n#include <boost/shared_ptr.hpp>\n#include <boost/asio/io_service.hpp>\n#include <boost/filesystem.hpp>\n#include <bitset>\n#include \"nibbler.hpp\"\n#include \"ISound.hpp\"\n#include <boost/asio/deadline_timer.hpp>\n#include <events/NextFrame.hpp>\n#include <boost/thread.hpp>\n\n#define PATH_DISPLAY_LIBRARY_SFML \"dynamicLibraries/libdisplay_sfml.so\"\n#define PATH_DISPLAY_LIBRARY_GLFW \"dynamicLibraries/libdisplay_glfw.so\"\n#define PATH_DISPLAY_LIBRARY_SDL \"dynamicLibraries/libdisplay_sdl.so\"\n\n#define PATH_SOUND_LIBRARY_SFML \"dynamicLibraries/libsound_sfml.so\"\n#define PATH_SOUND_LIBRARY_SDL \"dynamicLibraries/libsound_sdl.so\"\n\nclass ServerTCP;\n\nclass SnakeServer;\n\nclass SnakeClient;\n\nclass ClientTCP;\n\nclass Core;\n\nnamespace KINU {\n\n\tclass World;\n};\n\nclass Univers {\npublic:\n\n\tenum eDisplay {\n\t\tkExternSfmlLibrary,\n\t\tkExternSdlLibrary,\n\t\tkExternGlfwLibrary\n\t};\n\n\tenum eFlag {\n\t\tSOUND\n\t};\n\n\tUnivers();\n\n\tbool load_extern_lib_display(eDisplay);\n\n\tbool load_external_sound_library(\n\t\t\tstd::string const &library_path); // TODO GO PRIVATE\n\tvoid unload_external_library();\n\n\tvoid loop();\n\n\tvoid manage_start();\n\n\tvoid new_game();\n\n\tvoid defaultAssignmentLibrary();\n\n\tCore &getCore_() const;\n\n\tCore *releaseCore_();\n\n\tvoid refreshTimerLoopWorld();\n\n\tvoid addNoise(std::string const &path);\n\n\tvoid playNoise(eSound e) const;\n\n\tvoid playMusic(std::string const &path) const;\n\n\tbool isIASnake(uint16_t client_id) const;\n\n\tvoid connect(std::string const &dns = \"localhost\",\n\t\t\t\t std::string const &port = \"4242\");\n\n\t/** Create && Delete function**/\n\n\tvoid create_ia();\n\n\tvoid create_server(unsigned int port = 4242);\n\n\tvoid create_client();\n\n\tvoid create_ui(); // TODO PRIVATE\n\n\tvoid delete_ia();\n\n\tvoid delete_server();\n\n\tvoid delete_client();\n\n\t/** Setter && Getter**/\n\n\tconst std::unique_ptr<SnakeServer> &getServerTCP_() const;\n\n\tMutantGrid<eSprite> &getGrid_();\n\n\t//Network\n\tstd::array<Snake, SNAKE_MAX> getSnakeArray_() const;\n\n\tSnakeClient *getSnakeClient() const;\n\n\t//Game\n\n\tKINU::World &getWorld_() const;\n\n\tvoid setMapSize(unsigned int mapSize_);\n\n\tbool isBorderless() const;\n\n\tvoid setBorderless(bool borderless);\n\n\tunsigned int getMapSize() const;\n\n\t//Flag\n\n\tvoid setFlag(eFlag);\n\n\tvoid unsetFlag(eFlag);\n\n\tbool testFlag(eFlag);\n\n\t//Sound\n\n\tISound &getSound() const;\n\n\t//State\n\n\tbool isOnlyIA() const;\n\n\tbool isServer() const;\n\n\tvoid callbackAction(eAction);\n\n\tvoid manageSwitchLibrary();\n\n\tvirtual ~Univers();\n\n\tbool isOpenGame_() const;\n\n\tvoid setOpenGame_(bool openGame_);\n\nprivate: // Function\n\n\tvoid cleanAll();\n\n\tvoid manage_input();\n\n\tvoid loop_world();\n\n\tbool dlError(char const *from);\n\nprivate:\n\n\t//const\n\n\tstatic const std::string SuccessServerIsCreate;\n\tstatic const std::string SuccessClientIsCreate;\n\tstatic const std::string SuccessClientIsDelete;\n\tstatic const std::string SuccessServerIsDelete;\n\tstatic const std::string SuccessIAIsCreate;\n\tstatic const std::string SuccessClientIsConnected;\n\n\tstatic const std::string WarningServerCreateIA;\n\tstatic const std::string WarningServerFull;\n\n\tstatic const std::string WarningServerExist;\n\tstatic const std::string WarningClientExist;\n\n\tstatic const std::string WarningClientNotExist;\n\tstatic const std::string WarningServerNotExist;\n\n\tstatic const std::string WarningClientIsAlreadyConnected;\n\tstatic const std::string WarningClientIsNotConnected;\n\n\tstatic const std::string WarningUserIsNotTheServer;\n\tstatic const std::string WarningRequiredAtLeastOneClient;\n\tboost::filesystem::path pathRoot_;\n\n\tbool switchLib;\n\t// Variable\n\tstd::vector<NextFrame> nextFrame;\n\tstd::bitset<32> flag;\n\tboost::asio::io_service io_loop;\n\tboost::asio::io_service io_start;\n\tboost::asio::deadline_timer timer_loop;\n\tboost::asio::deadline_timer timer_start;\n\tstd::shared_ptr<KINU::World> world_;\n\n\tstd::unique_ptr<SnakeServer> serverTCP_;\n\tstd::shared_ptr<SnakeClient> clientTCP_;\n\tstd::unique_ptr<Core> core_;\n\tstd::shared_ptr<MutantGrid<eSprite>> grid_;\n\nprivate:\n\n\tstd::vector<std::unique_ptr<Bobby>> vecBobby;\n\n\tunsigned int mapSize_;\n\tunsigned int gameSpeed;\n\tvoid *dlHandleDisplay;\n\tvoid *dlHandleSound;\n\tIDisplay *display;\n\tISound *sound;\n\tbool borderless;\n\tbool openGame_;\n\n\n\tboost::thread thread;\n\teDisplay kDisplay;\n\n\tbool load_external_display_library(std::string const &title,\n\t\t\t\t\t\t\t\t\t   std::string const &libPath);\n\n\tvoid finish_game();\n\n\tIDisplay *(*newDisplay)(int, int, char const *);\n\n\tISound *(*newSound)(char const *);\n\n\tvoid (*deleteDisplay)(IDisplay *);\n\n\tvoid (*deleteSound)(ISound *);\n\n};\n\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- nibblerSources/class/Univers.hpp	(revision 07b470cbef61f38d4cb872a376d05d61aec26e6d)
+++ nibblerSources/class/Univers.hpp	(date 1549558531000)
@@ -38,9 +38,14 @@
 public:
 
 	enum eDisplay {
-		kExternSfmlLibrary,
-		kExternSdlLibrary,
-		kExternGlfwLibrary
+		kDisplaySfmlLibrary,
+		kDisplaySdlLibrary,
+		kDisplayGlfwLibrary
+	};
+
+	enum eSound {
+		kSoundSfmlLibrary,
+		kSoundSdlLibrary
 	};
 
 	enum eFlag {
@@ -51,9 +56,11 @@
 
 	bool load_extern_lib_display(eDisplay);
 
-	bool load_external_sound_library(
-			std::string const &library_path); // TODO GO PRIVATE
-	void unload_external_library();
+	bool load_extern_lib_sound(eSound eLib);
+
+	void unload_external_sound_library();
+
+	void unload_external_display_library();
 
 	void loop();
 
@@ -71,7 +78,7 @@
 
 	void addNoise(std::string const &path);
 
-	void playNoise(eSound e) const;
+	void playNoise(eNoise e) const;
 
 	void playMusic(std::string const &path) const;
 
@@ -119,13 +126,6 @@
 
 	unsigned int getMapSize() const;
 
-	//Flag
-
-	void setFlag(eFlag);
-
-	void unsetFlag(eFlag);
-
-	bool testFlag(eFlag);
 
 	//Sound
 
@@ -182,12 +182,12 @@
 
 	static const std::string WarningUserIsNotTheServer;
 	static const std::string WarningRequiredAtLeastOneClient;
+
+	// Variable
 	boost::filesystem::path pathRoot_;
-
+	std::bitset<32> flag_;
 	bool switchLib;
-	// Variable
 	std::vector<NextFrame> nextFrame;
-	std::bitset<32> flag;
 	boost::asio::io_service io_loop;
 	boost::asio::io_service io_start;
 	boost::asio::deadline_timer timer_loop;
@@ -218,6 +218,7 @@
 
 	bool load_external_display_library(std::string const &title,
 									   std::string const &libPath);
+	bool load_external_sound_library(std::string const &library_path);
 
 	void finish_game();
 
Index: nibblerSources/class/Univers.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"Univers.hpp\"\n#include <gui/Core.hpp>\n#include <systems/MotionSystem.hpp>\n#include <systems/JoystickSystem.hpp>\n#include <systems/FollowSystem.hpp>\n#include <systems/FoodCreationSystem.hpp>\n#include <systems/CollisionSystem.hpp>\n#include <systems/SpriteSystem.hpp>\n#include <systems/RenderSystem.hpp>\n#include <systems/FoodEatSystem.hpp>\n#include <events/FoodEat.hpp>\n#include <KINU/World.hpp>\n#include <events/StartEvent.hpp>\n#include <events/FoodCreation.hpp>\n#include <events/JoystickEvent.hpp>\n#include <dlfcn.h>\n#include <network/SnakeServer.hpp>\n#include <network/SnakeClient.hpp>\n\n/** Const Variable **/\nconst std::string Univers::SuccessServerIsCreate = \"Server is online.\";\nconst std::string Univers::SuccessIAIsCreate = \"IA is online.\";\nconst std::string Univers::SuccessClientIsConnected = \"Client is connected.\";\nconst std::string Univers::SuccessClientIsCreate = \"Client is online\";\nconst std::string Univers::SuccessClientIsDelete = \"Client is delete.\";\nconst std::string Univers::SuccessServerIsDelete = \"Server is delete.\";\n\nconst std::string Univers::WarningClientExist = \"Client is already in place.\";\nconst std::string Univers::WarningServerCreateIA = \"Only the server owner can create IA.\";\nconst std::string Univers::WarningServerFull = \"Server have reach the maximum player.\";\nconst std::string Univers::WarningServerExist = \"Server is left online.\";\nconst std::string Univers::WarningClientNotExist = \"There is no client online.\";\nconst std::string Univers::WarningServerNotExist = \"There is no server online.\";\nconst std::string Univers::WarningClientIsAlreadyConnected = \"Client is already connected.\";\nconst std::string Univers::WarningClientIsNotConnected = \"Client is not connected.\";\nconst std::string Univers::WarningUserIsNotTheServer = \"User is not the server.\";\nconst std::string Univers::WarningRequiredAtLeastOneClient = \"You need to have at least one client to start game.\";\n\nUnivers::Univers()\n\t\t: pathRoot_(NIBBLER_ROOT_PROJECT_PATH),\n\t\t\tswitchLib(false),\n\t\t  timer_loop(boost::asio::deadline_timer(io_loop)),\n\t\t  timer_start(boost::asio::deadline_timer(io_start)),\n\t\t  world_(nullptr),\n\t\t  serverTCP_(nullptr),\n\t\t  clientTCP_(nullptr),\n\t\t  core_(nullptr),\n\t\t  grid_(nullptr),\n\t\t  mapSize_(MAP_DEFAULT),\n\t\t  gameSpeed(100),\n\t\t  dlHandleDisplay(nullptr),\n\t\t  dlHandleSound(nullptr),\n\t\t  display(nullptr),\n\t\t  sound(nullptr),\n\t\t  borderless(false),\n\t\t  openGame_(false),\n\t\t  kDisplay(eDisplay::kExternSfmlLibrary) {\n\t\t  }\n\n/** External Library Management **/\n\n\nbool Univers::load_external_sound_library(std::string const &library_path) {\n\tif (sound != nullptr && dlHandleSound != nullptr) {\n\t\tif (deleteSound) {\n\t\t\tdeleteSound(sound);\n\t\t\tdeleteSound = nullptr;\n\t\t\tnewSound = nullptr;\n\t\t}\n\t\tdlclose(dlHandleSound);\n\t}\n\n\tif (!(dlHandleSound = dlopen(library_path.c_str(), RTLD_LAZY | RTLD_LOCAL)))\n\t\treturn (dlError(\"dlopen\"));\n\n\tif (!(newSound = reinterpret_cast<ISound *(*)(\n\t\t\tconst char *) >(dlsym(dlHandleSound, \"newSound\"))))\n\t\treturn (dlError(\"dlsym\"));\n\n\tif (!(deleteSound = reinterpret_cast<void (*)(\n\t\t\tISound *)>(dlsym(dlHandleSound, \"deleteSound\"))))\n\t\treturn (dlError(\"dlsym\"));\n\treturn (sound = newSound(library_path.c_str())) != nullptr;\n}\n\nbool Univers::load_external_display_library(std::string const &title,\n\t\t\t\t\t\t\t\t\t\t\tstd::string const &libPath) {\n\n\tif (!(dlHandleDisplay = dlopen(libPath.c_str(), RTLD_LAZY | RTLD_LOCAL)))\n\t\treturn (dlError(\"dlopen\"));\n\tif (!(newDisplay = reinterpret_cast<IDisplay *(*)(\n\t\t\tint, int, const char *\n\t)>(dlsym(dlHandleDisplay, \"newDisplay\"))))\n\t\treturn (dlError(\"dlsym\"));\n\tif (!(deleteDisplay = reinterpret_cast<void (*)(\n\t\t\tIDisplay *\n\t)>(dlsym(dlHandleDisplay, \"deleteDisplay\"))))\n\t\treturn (dlError(\"dlsym\"));\n\tif (!(display = newDisplay(mapSize_, mapSize_, title.c_str())))\n\t\treturn (false);\n\n\tlog_success(\"load_external_display_library up !\");\n\treturn (true);\n}\n\nbool Univers::load_extern_lib_display(Univers::eDisplay eLib) {\n\tswitch (eLib) {\n\t\tcase kExternSfmlLibrary : {\n\t\t\tlog_success(\"Univers::load_extern_lib_display.kExternSfmlLibrary\");\n\t\t\treturn load_external_display_library(\n\t\t\t\t\tstd::string(\"Nibbler - SFML\"),\n\t\t\t\t\tstd::string(PATH_DISPLAY_LIBRARY_SFML)\n\t\t\t\t\t);\n\t\t}\n\t\tcase kExternSdlLibrary : {\n\t\t\tlog_success(\"Univers::load_extern_lib_display.kExternSdlLibrary\");\n\t\t\treturn load_external_display_library(\n\t\t\t\t\tstd::string(\"Nibbler - SDL\"),\n\t\t\t\t\tstd::string(PATH_DISPLAY_LIBRARY_SDL)\n\t\t\t);\t\t}\n\t\tcase kExternGlfwLibrary : {\n\t\t\tlog_success(\"Univers::load_extern_lib_display.kExternGlfwLibrary\");\n\t\t\treturn load_external_display_library(\n\t\t\t\t\tstd::string(\"Nibbler - GLFW\"),\n\t\t\t\t\tstd::string(PATH_DISPLAY_LIBRARY_GLFW)\n\t\t\t);\t\t}\n\t}\n\treturn false;\n}\n\nvoid Univers::unload_external_library() {\n\tlog_error(\"Univers::unload_external_library\");\n\tif (display != nullptr && dlHandleDisplay != nullptr) {\n\t\tif (deleteDisplay) {\n\t\t\tdeleteDisplay(display);\n\t\t\tdeleteDisplay = nullptr;\n\t\t\tnewDisplay = nullptr;\n\t\t\tdisplay = nullptr;\n\t\t}\n\t\tdlclose(dlHandleDisplay);\n\t\tdlHandleDisplay = nullptr;\n\t}\n\tlog_error(\"Univers::unload_external_library.unlock()\");\n}\n\n/** Game Management **/\n\n\nvoid Univers::defaultAssignmentLibrary() {\n\tif (!display) return;\n\n\tMutantGrid<eSprite> grid(mapSize_);\n\tgrid.fill(eSprite::GROUND);\n\tdisplay->setBackground(grid);\n\tdisplay->registerCallbackAction(std::bind(&Univers::callbackAction, this, std::placeholders::_1));\n\tdisplay->update(0.17f);\n\tdisplay->render(1.f, 1.f);\n}\n\nvoid Univers::new_game() {\n\tlog_info(\"%s\", __PRETTY_FUNCTION__);\n\tio_loop.restart();\n\tio_start.restart();\n\tlog_info(\"Hello i'am a %s\", isServer() ? \"Server\" : \"Client\");\n\tworld_ = std::make_unique<KINU::World>();\n\tworld_->getEventsManager().destroy<FoodCreation>();\n\tgrid_ = std::make_shared<MutantGrid<eSprite>>(mapSize_);\n\tgrid_->fill(eSprite::NONE);\n\tif (!display) load_extern_lib_display(kDisplay);\n\tdefaultAssignmentLibrary();\n\tif (isServer()) {\n\t\tserverTCP_->startGame();\n\t\tfor (std::unique_ptr<Bobby> &bobby : vecBobby) {\n\t\t\tbobby->buildIA();\n\t\t\tbobby->sendDirection();\n\t\t}\n\n\t}\n\n\tworld_->getSystemsManager().addSystem<CollisionSystem>(*this);\n\tworld_->getSystemsManager().addSystem<FollowSystem>();\n\tworld_->getSystemsManager().addSystem<JoystickSystem>(*this);\n\tworld_->getSystemsManager().addSystem<MotionSystem>(*this);\n\tworld_->getSystemsManager().addSystem<SpriteSystem>(*this);\n\tworld_->getSystemsManager().addSystem<RenderSystem>(*this);\n\tworld_->getSystemsManager().addSystem<FoodCreationSystem>();\n\tworld_->getSystemsManager().addSystem<FoodEatSystem>();\n\n\tmanage_start();\n\n\tworld_->update();\n\tworld_->getSystemsManager().getSystem<SpriteSystem>().update();\n\tworld_->getSystemsManager().getSystem<RenderSystem>().update();\n\n\ttimer_loop.async_wait(boost::bind(&Univers::loop_world, this));\n\tthread = boost::thread(\n\t\t\tboost::bind(&boost::asio::io_service::run, &io_loop));\n\tthread.detach();\n\n\tloop();\n}\n\nvoid Univers::manage_input() {\n\tlog_info(\"%s %d\",__PRETTY_FUNCTION__,  clientTCP_ != nullptr);\n\tif (clientTCP_) {\n\t\tif (clientTCP_->getSnake().isAlive)\n\t\t\tclientTCP_->sendDataToServer(InputInfo(clientTCP_->getId_(),\n\t\t\t\t\t(display ? display->getDirection() : eDirection::kNorth)),\n\t\t\t\t\t\t\teHeaderK::kInput);\n\t}\n\n}\n\nvoid Univers::manage_start() {\n\tlog_info(\"%s\", __PRETTY_FUNCTION__);\n\tStartInfo startInfo;\n\tstd::vector<StartEvent> startEvent;\n\tfor (; startEvent.empty();) {\n\n\t\tgetSnakeClient()->lock();\n\t\tstartEvent = world_->getEventsManager().getEvents<StartEvent>();\n\t\tgetSnakeClient()->unlock();\n\t}\n\tauto ptime = startEvent.front().start_time;\n\ttimer_start.expires_at(ptime);\n\tio_start.run();\n\ttimer_start.wait();\n\ttimer_loop.expires_at(ptime + boost::posix_time::milliseconds(gameSpeed));\n\tif (isServer()) {\n\t\tfor (auto &bobby : vecBobby) {\n\t\t\tbobby->sendDirection();\n\t\t}\n\t}\n}\n\n\nvoid Univers::loop() {\n\tlog_info(\"%s\", __PRETTY_FUNCTION__);\n\n\tplayMusic(MUSIC_ZELDA);\n\n\tstd::chrono::high_resolution_clock::time_point t1 = std::chrono::high_resolution_clock::now();\n\tstd::chrono::milliseconds current(0);\n\tstd::cout << \"AllSnakeIsDead : \" << getSnakeClient()->allSnakeIsDead() << std::endl;\n\twhile (openGame_ && (display == nullptr || !display->exit()) &&\n\t\t   !getSnakeClient()->allSnakeIsDead()) {\n\t\tif (switchLib)\n\t\t\tmanageSwitchLibrary();\n\t\tstd::chrono::high_resolution_clock::time_point t2 = std::chrono::high_resolution_clock::now();\n\t\tstd::chrono::milliseconds time_span = std::chrono::duration_cast<std::chrono::milliseconds>(t2 - t1);\n\t\tt1 = t2;\n\t\tcurrent += time_span;\n\n\t\tif (current > std::chrono::milliseconds(gameSpeed))\n\t\t\tcurrent = std::chrono::milliseconds(gameSpeed);\n\n\t\t//std::cout << \"It took me \" << current.count() << \",\" << gameSpeed << \" seconds.\" << std::endl;\n\t\tdisplay->update(0.017f);\n\t\tdisplay->drawGrid(*grid_);\n\t\tdisplay->render(0.017f, 1.f);\n//\t\t\tdisplay->update(0.2f);\n//\t\t\tdisplay->drawGrid(world_->grid);\n//\t\t\tdisplay->render(current.count(), gameSpeed);\n//\t\t\tdisplay->render(gameSpeed, gameSpeed);\n\t\tif (current >= std::chrono::milliseconds(gameSpeed)) {\n\t\t\tcurrent = std::chrono::milliseconds(0);\n\t\t}\n\t}\n\tunload_external_library();\n\tfinish_game();\n}\n\nvoid Univers::loop_world() {\n\tlog_warn(\"World is not %s !!!\", world_ ? \"UP\" : \"DOWN\");\n\tif (!openGame_ || !getSnakeClient())\n\t\treturn;\n\tmanage_input();\n\n\tfor (; nextFrame.empty() && openGame_ && world_ && getSnakeClient();) {\n\t\tgetSnakeClient()->lock();\n//\t\t std::cout << \"Stuck nextFrame\" << std::endl;\n\t\tnextFrame = world_->getEventsManager().getEvents<NextFrame>();\n\t\tgetSnakeClient()->unlock();\n\t}\n\tif (!openGame_ || !getSnakeClient())\n\t\treturn;\n\tnextFrame.clear();\n\tworld_->getEventsManager().destroy<NextFrame>();\n\n\tgetSnakeClient()->deliverEvents();\n\n\tworld_->update();\n\n//\tlog_info(\"Univers::FollowSystem\");\n\tworld_->getSystemsManager().getSystem<FollowSystem>().update();\n//\tlog_info(\"Univers::JoystickSystem\");\n\tworld_->getSystemsManager().getSystem<JoystickSystem>().update();\n//\tlog_info(\"Univers::JoystickEvent\");\n\tworld_->getEventsManager().destroy<JoystickEvent>();\n//\tlog_info(\"Univers::MotionSystem\");\n\tworld_->getSystemsManager().getSystem<MotionSystem>().update();\n//\tlog_info(\"Univers::CollisionSystem\");\n\tworld_->getSystemsManager().getSystem<CollisionSystem>().update();\n//\tlog_info(\"Univers::FoodCreationSystem\");\n\tworld_->getSystemsManager().getSystem<FoodCreationSystem>().update();\n\tworld_->getEventsManager().destroy<FoodCreation>();\n//\tlog_info(\"Univers::SpriteSystem\");\n\tworld_->getSystemsManager().getSystem<SpriteSystem>().update();\n//\tlog_info(\"Univers::RenderSystem\");\n\tworld_->getSystemsManager().getSystem<RenderSystem>().update();\n//\tlog_info(\"Univers::FoodEatSystem\");\n\n//\tlog_info(\"Univers::vecBobby\");\n\tBobby::clearPriority();\n\tif (isServer()) {\n\t\tfor (auto &bobby : vecBobby) {\n\t\t\tif (world_->getEntitiesManager().hasEntityByTagId(\n\t\t\t\t\tbobby->getId() + eTag::HEAD_TAG)) {\n\t\t\t\tboost::thread\n\t\t\t\t\t\tt2(\n\t\t\t\t\t\tboost::bind(&Bobby::calculateDirection, bobby.get()));\n\t\t\t\tt2.detach();\n\t\t\t}\n\n\t\t}\n\t}\n\n\n\tworld_->getSystemsManager().getSystem<FoodEatSystem>().update();\n\tworld_->getEventsManager().destroy<FoodEat>();\n\n\tif (!getSnakeClient()->allSnakeIsDead()) {\n\n\t\ttimer_loop.expires_at(\n\t\t\t\ttimer_loop.expires_at() +\n\t\t\t\tboost::posix_time::milliseconds(gameSpeed));\n\t\ttimer_loop.async_wait(boost::bind(&Univers::loop_world, this));\n\t}\n//\tworld_->grid.print();\n}\n\nvoid Univers::manageSwitchLibrary() {\n\tlog_success(\"sw %d\", !getSnakeClient()->isSwitchingLibrary());\n\tif (!getSnakeClient()->isSwitchingLibrary()) {\n\t\tint16_t id = getSnakeClient()->getId_();\n\t\tgetSnakeClient()->sendDataToServer(id, eHeaderK::kForcePause);\n\t\tkDisplay = (kDisplay == kExternGlfwLibrary) ? kExternSfmlLibrary : static_cast<eDisplay>(kDisplay + 1);\n\t\tunload_external_library();\n\t\tstd::cout << load_extern_lib_display(kDisplay) << std::endl;\n\t\tdefaultAssignmentLibrary();\n\t\tgetSnakeClient()->sendDataToServer(id, eHeaderK::kForcePause);\n\t}\n\tswitchLib = false;\n}\n\nvoid Univers::refreshTimerLoopWorld() {\n\ttimer_loop.expires_at(boost::posix_time::microsec_clock::universal_time());\n}\n\nvoid Univers::callbackAction(eAction action) {\n//\tif (getSnakeClient() == nullptr) return;\n\tswitch (action) {\n\t\tcase eAction::kPause :\n\t\t\tlog_success(\" eAction::kPause\");\n\t\t\tgetSnakeClient()->sendDataToServer(action, eHeaderK::kPause);\n\t\t\tbreak;\n\t\tcase eAction::kSwitchDisplayLibrary:\n\t\t\tlog_success(\"eAction::kSwitchDisplayLibrary\");\n\t\t\tswitchLib = true;\n\t\t\tbreak;\n\t\tcase eAction::kCreateClient :\n\t\t\tcreate_client();\n\t\t\tbreak;\n\t\tcase eAction::kDeleteClient :\n\t\t\tdelete_client();\n\t\t\tbreak;\n\t\tcase eAction::kCreateServer :\n\t\t\tcreate_server();\n\t\t\tbreak;\n\t\tcase eAction::kDeleteServer :\n\t\t\tdelete_server();\n\t\t\tbreak;\n\t\tcase eAction::kCreateIA :\n\t\t\tcreate_ia();\n\t\t\tbreak;\n\t\tcase eAction::kDeleteIA :\n\t\t\tbreak;\n\t\tcase eAction::kConnect :\n\t\t\tconnect();\n\t\t\tbreak;\n\t\tcase eAction::kBorderless :\n\t\t\tif (getSnakeClient())\n\t\t\t\tgetSnakeClient()->changeIsBorderless(!isBorderless());\n\t\t\telse\n\t\t\t\tcore_->addMessageChat(WarningClientNotExist);\n\t\t\tbreak;\n\t\tcase eAction::kReady :\n\t\t\tif (!getSnakeClient()) {\n\t\t\t\tcore_->addMessageChat(WarningClientNotExist);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!getSnakeClient()->isConnect()) {\n\t\t\t\tcore_->addMessageChat(WarningClientIsNotConnected);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgetSnakeClient()->changeStateReady(!getSnakeClient()->isReady());\n\t\t\tbreak;\n\t\tcase eAction::kStartGame :\n\t\t\tif (!isServer()) {\n\t\t\t\tcore_->addMessageChat(WarningUserIsNotTheServer);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!getSnakeClient()) {\n\t\t\t\tcore_->addMessageChat(WarningRequiredAtLeastOneClient);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgetServerTCP_()->sendOpenGameToClient();\n\t\t\tbreak;\n\t}\n}\n\n/** Create and delete **/\n\n\nvoid Univers::create_client() {\n\tif (!clientTCP_) {\n\t\tclientTCP_ = std::make_unique<SnakeClient>(*this, false);\n\t\tcore_->addMessageChat(SuccessClientIsCreate);\n\t}\n\telse\n\t\tcore_->addMessageChat(WarningClientExist);\n}\n\nvoid Univers::create_ui() {\n\tcore_ = std::make_unique<Core>(*this);\n}\n\nvoid Univers::create_server(unsigned int port) {\n\tif (serverTCP_)\n\t\tcore_->addMessageChat(WarningServerExist);\n\telse {\n\t\ttry {\n\t\t\tserverTCP_ = std::make_unique<SnakeServer>(*this, port);\n\t\t\tcore_->addMessageChat(SuccessServerIsCreate);\n\t\t} catch (std::exception const &e) {\n\t\t\tcore_->addMessageChat(e.what());\n\t\t}\n\t}\n\n\n}\n\nvoid Univers::connect(const std::string &dns, const std::string &port) {\n\tif (isOnlyIA() || !getSnakeClient()) {\n\t\tcore_->addMessageChat(WarningClientNotExist);\n\t\treturn;\n\t}\n\tlog_fatal(\"connect %d\", getSnakeClient()->isConnect());\n\tif (getSnakeClient()->isConnect()) {\n\t\tcore_->addMessageChat(WarningClientIsAlreadyConnected);\n\t\treturn;\n\t}\n\ttry {\n\t\tgetSnakeClient()->connect(dns, port);\n\t\tcore_->addMessageChat(SuccessClientIsConnected);\n\t} catch (std::exception const &e) {\n\t\tcore_->addMessageChat(e.what());\n\t}\n}\n\nvoid Univers::create_ia() {\n\tif (!isServer()) {\n\t\tcore_->addMessageChat(WarningServerCreateIA);\n\t\treturn;\n\t}\n\tif (serverTCP_->isFull()) {\n\t\tcore_->addMessageChat(WarningServerFull);\n\t\treturn;\n\t}\n\tstd::unique_ptr<Bobby> bobby = std::make_unique<Bobby>(*this);\n\tbobby->getClientTCP_()->connect(\"localhost\", std::to_string(serverTCP_->getPort_()));\n\tvecBobby.push_back(std::move(bobby));\n\tcore_->addMessageChat(SuccessIAIsCreate);\n}\n\nvoid Univers::delete_ia() {\n\tfor (auto &bobby : vecBobby) {\n\t\tgetSnakeArray_()[bobby->getId()].isValid = false;\n\t}\n\tvecBobby.clear();\n}\n\nvoid Univers::delete_server() {\n\tif (serverTCP_) {\n\t\tserverTCP_ = nullptr;\n\t\tcore_->addMessageChat(SuccessServerIsDelete);\n\t\tif (clientTCP_ && clientTCP_->isConnect())\n\t\t\tdelete_client();\n\t} else {\n\t\tcore_->addMessageChat(WarningServerNotExist);\n\t}\n}\n\nvoid Univers::delete_client() {\n\tif (clientTCP_) {\n\t\tclientTCP_ = nullptr;\n\t\tcore_->addMessageChat(SuccessClientIsDelete);\n\t}\n\telse\n\t\tcore_->addMessageChat(WarningClientNotExist);\n}\n\nvoid Univers::finish_game() {\n\tcleanAll();\n}\n\n\n/** Getter && Setter **/\n\nMutantGrid<eSprite> &Univers::getGrid_() {\n\treturn *grid_;\n}\n\nstd::array<Snake, SNAKE_MAX> Univers::getSnakeArray_() const {\n\tif (isServer())\n\t\treturn serverTCP_->getSnakeArray_();\n\tif (getSnakeClient())\n\t\treturn getSnakeClient()->getSnakeArray_();\n\treturn std::array<Snake, SNAKE_MAX>();\n}\n\n\nKINU::World &Univers::getWorld_() const {\n\treturn *world_;\n}\n\nSnakeClient *Univers::getSnakeClient() const {\n\tif (clientTCP_)\n\t\treturn clientTCP_.get();\n\telse if (vecBobby.size() != 0)\n\t\treturn vecBobby.front()->getClientTCP_();\n\treturn nullptr;\n}\n\nISound &Univers::getSound() const {\n\treturn *sound;\n}\n\nCore &Univers::getCore_() const {\n\treturn *core_;\n}\n\nunsigned int Univers::getMapSize() const {\n\treturn mapSize_;\n}\n\nvoid Univers::setMapSize(unsigned int mapSize) {\n\tmapSize_ = mapSize;\n\tlog_success(\"New map size [%d]\", mapSize_);\n}\n\nvoid Univers::setBorderless(bool borderless) {\n\tUnivers::borderless = borderless;\n}\n\n/** State **/\n\nbool Univers::isServer() const {\n\treturn serverTCP_ != nullptr;\n}\n\nbool Univers::isBorderless() const {\n\treturn borderless;\n}\n\nbool Univers::isOnlyIA() const {\n\treturn clientTCP_ == nullptr && vecBobby.size() != 0;\n}\n\n/** Sound **/\n\nvoid Univers::addNoise(std::string const &path) {\n\tstd::cout << \"Y\\n\";\n\tif (sound && flag.test(eFlag::SOUND)) {\n\t\tstd::cout << \"I\\n\";\n\t\tsound->addNoise(path);\n\t}\n}\nvoid Univers::playNoise(eSound e) const {\n\tif (sound && flag.test(eFlag::SOUND))\n\t\tsound->playNoise(static_cast<int>(e));\n}\nvoid Univers::playMusic(std::string const &path) const {\n\tif (sound && flag.test(eFlag::SOUND)) {\n\t\tsound->setMusic(path.c_str());\n\t\tsound->playMusic();\n\t}\n}\n\n\nCore *Univers::releaseCore_() {\n\treturn (core_.release());\n}\n\nvoid Univers::setFlag(eFlag flag_) {\n\tflag.set(flag_);\n}\n\nvoid Univers::unsetFlag(eFlag flag_) {\n\tflag.reset(flag_);\n}\n\n\nbool Univers::testFlag(eFlag flag_) {\n\treturn (flag.test(flag_));\n}\n\n/** Error **/\n\nbool Univers::dlError(char const *from) {\n\tstd::cerr << \"Error \" << from << \" : \" << dlerror() << std::endl;\n\tdlclose(dlHandleDisplay);\n\treturn (false);\n}\n\nbool Univers::isIASnake(uint16_t client_id) const {\n\n\tfor (auto &bobby : vecBobby) {\n\t\tif (bobby->getId() == client_id)\n\t\t\treturn true;\n\t}\n\treturn false;\n}\n\nUnivers::~Univers() {\n\tlog_warn(\"~Univers\");\n\tcleanAll();\n\tclientTCP_ = nullptr;\n\tserverTCP_ = nullptr;\n\tunload_external_library();\n\tlog_warn(\"~Univers.end()\");\n}\n\nconst std::unique_ptr<SnakeServer> &Univers::getServerTCP_() const {\n\treturn serverTCP_;\n}\n\nbool Univers::isOpenGame_() const {\n\treturn openGame_;\n}\n\nvoid Univers::setOpenGame_(bool openGame) {\n\tUnivers::openGame_ = openGame;\n}\n\nvoid Univers::cleanAll() {\n\topenGame_ = false;\n\ttimer_loop.wait();\n\ttimer_start.wait();\n\tthread.join();\n\tio_loop.reset();\n\tio_start.reset();\n\ttimer_loop.cancel();\n\ttimer_start.cancel();\n\tswitchLib = false;\n\tnextFrame.clear();\n\tworld_ = nullptr;\n\tlog_info(\"getSnakeClient(%d) && !getSnakeClient()->isConnect(%d)\",\n\t\t\tgetSnakeClient() != nullptr , getSnakeClient() ? !getSnakeClient()->isConnect() : -42);\n\tif (getSnakeClient() && !getSnakeClient()->isConnect()) {\n\t\tdelete_server();\n\t\tdelete_client();\n\t\tfor (Snake &snake: getSnakeArray_()) {\n\t\t\tlog_fatal(\"Snake [%d]isValid?[%d]\", snake.id, snake.isValid);\n\t\t}\n\t\tborderless = false;\n\t\tmapSize_ = MAP_DEFAULT;\n\t}\n\tcore_ = nullptr;\n\tgrid_ = nullptr;\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- nibblerSources/class/Univers.cpp	(revision 07b470cbef61f38d4cb872a376d05d61aec26e6d)
+++ nibblerSources/class/Univers.cpp	(date 1549558890000)
@@ -38,7 +38,8 @@
 
 Univers::Univers()
 		: pathRoot_(NIBBLER_ROOT_PROJECT_PATH),
-			switchLib(false),
+		  flag_(0),
+		  switchLib(false),
 		  timer_loop(boost::asio::deadline_timer(io_loop)),
 		  timer_start(boost::asio::deadline_timer(io_start)),
 		  world_(nullptr),
@@ -54,7 +55,7 @@
 		  sound(nullptr),
 		  borderless(false),
 		  openGame_(false),
-		  kDisplay(eDisplay::kExternSfmlLibrary) {
+		  kDisplay(eDisplay::kDisplaySfmlLibrary) {
 		  }
 
 /** External Library Management **/
@@ -83,6 +84,37 @@
 	return (sound = newSound(library_path.c_str())) != nullptr;
 }
 
+bool Univers::load_extern_lib_sound(Univers::eSound eLib) {
+	flag_.set(eFlag::SOUND);
+	switch (eLib) {
+		case kSoundSdlLibrary : {
+			log_success("Univers::load_extern_lib_sound.kSoundSdlLibrary");
+		}
+		case kSoundSfmlLibrary : {
+			log_success("Univers::load_extern_lib_sound.kSoundSfmlLibrary");
+			return load_external_sound_library(boost::filesystem::path(PATH_SOUND_LIBRARY_SFML).generic_string());
+		}
+	}
+	flag_.reset(eFlag::SOUND);
+	return false;
+}
+
+void Univers::unload_external_sound_library() {
+	log_error("Univers::unload_external_sound_library");
+	if (sound != nullptr && dlHandleSound != nullptr) {
+		if (deleteSound) {
+			deleteSound(sound);
+			deleteSound = nullptr;
+			newSound = nullptr;
+			sound = nullptr;
+		}
+		dlclose(dlHandleSound);
+		dlHandleSound = nullptr;
+		flag_.reset(eFlag::SOUND);
+	}
+	log_error("Univers::unload_external_sound_library.unlock()");
+}
+
 bool Univers::load_external_display_library(std::string const &title,
 											std::string const &libPath) {
 
@@ -105,31 +137,31 @@
 
 bool Univers::load_extern_lib_display(Univers::eDisplay eLib) {
 	switch (eLib) {
-		case kExternSfmlLibrary : {
-			log_success("Univers::load_extern_lib_display.kExternSfmlLibrary");
+		case kDisplaySfmlLibrary : {
+			log_success("Univers::load_extern_lib_display.kDisplaySfmlLibrary");
 			return load_external_display_library(
-					std::string("Nibbler - SFML"),
-					std::string(PATH_DISPLAY_LIBRARY_SFML)
+					"Nibbler - SFML",
+					boost::filesystem::path(PATH_DISPLAY_LIBRARY_SFML).generic_string()
 					);
 		}
-		case kExternSdlLibrary : {
-			log_success("Univers::load_extern_lib_display.kExternSdlLibrary");
+		case kDisplaySdlLibrary : {
+			log_success("Univers::load_extern_lib_display.kDisplaySdlLibrary");
 			return load_external_display_library(
-					std::string("Nibbler - SDL"),
-					std::string(PATH_DISPLAY_LIBRARY_SDL)
+					"Nibbler - SDL",
+					boost::filesystem::path(PATH_DISPLAY_LIBRARY_SDL).generic_string()
 			);		}
-		case kExternGlfwLibrary : {
-			log_success("Univers::load_extern_lib_display.kExternGlfwLibrary");
+		case kDisplayGlfwLibrary : {
+			log_success("Univers::load_extern_lib_display.kDisplayGlfwLibrary");
 			return load_external_display_library(
-					std::string("Nibbler - GLFW"),
-					std::string(PATH_DISPLAY_LIBRARY_GLFW)
+					"Nibbler - GLFW",
+					boost::filesystem::path(PATH_DISPLAY_LIBRARY_GLFW).generic_string()
 			);		}
 	}
 	return false;
 }
 
-void Univers::unload_external_library() {
-	log_error("Univers::unload_external_library");
+void Univers::unload_external_display_library() {
+	log_error("Univers::unload_external_display_library");
 	if (display != nullptr && dlHandleDisplay != nullptr) {
 		if (deleteDisplay) {
 			deleteDisplay(display);
@@ -140,7 +172,7 @@
 		dlclose(dlHandleDisplay);
 		dlHandleDisplay = nullptr;
 	}
-	log_error("Univers::unload_external_library.unlock()");
+	log_error("Univers::unload_external_display_library.unlock()");
 }
 
 /** Game Management **/
@@ -237,8 +269,6 @@
 void Univers::loop() {
 	log_info("%s", __PRETTY_FUNCTION__);
 
-	playMusic(MUSIC_ZELDA);
-
 	std::chrono::high_resolution_clock::time_point t1 = std::chrono::high_resolution_clock::now();
 	std::chrono::milliseconds current(0);
 	std::cout << "AllSnakeIsDead : " << getSnakeClient()->allSnakeIsDead() << std::endl;
@@ -266,7 +296,7 @@
 			current = std::chrono::milliseconds(0);
 		}
 	}
-	unload_external_library();
+	unload_external_display_library();
 	finish_game();
 }
 
@@ -344,8 +374,8 @@
 	if (!getSnakeClient()->isSwitchingLibrary()) {
 		int16_t id = getSnakeClient()->getId_();
 		getSnakeClient()->sendDataToServer(id, eHeaderK::kForcePause);
-		kDisplay = (kDisplay == kExternGlfwLibrary) ? kExternSfmlLibrary : static_cast<eDisplay>(kDisplay + 1);
-		unload_external_library();
+		kDisplay = (kDisplay == kDisplayGlfwLibrary) ? kDisplaySfmlLibrary : static_cast<eDisplay>(kDisplay + 1);
+		unload_external_display_library();
 		std::cout << load_extern_lib_display(kDisplay) << std::endl;
 		defaultAssignmentLibrary();
 		getSnakeClient()->sendDataToServer(id, eHeaderK::kForcePause);
@@ -581,17 +611,17 @@
 
 void Univers::addNoise(std::string const &path) {
 	std::cout << "Y\n";
-	if (sound && flag.test(eFlag::SOUND)) {
+	if (sound && flag_.test(eFlag::SOUND)) {
 		std::cout << "I\n";
 		sound->addNoise(path);
 	}
 }
-void Univers::playNoise(eSound e) const {
-	if (sound && flag.test(eFlag::SOUND))
+void Univers::playNoise(eNoise e) const {
+	if (sound && flag_.test(eFlag::SOUND))
 		sound->playNoise(static_cast<int>(e));
 }
 void Univers::playMusic(std::string const &path) const {
-	if (sound && flag.test(eFlag::SOUND)) {
+	if (sound && flag_.test(eFlag::SOUND)) {
 		sound->setMusic(path.c_str());
 		sound->playMusic();
 	}
@@ -602,19 +632,6 @@
 	return (core_.release());
 }
 
-void Univers::setFlag(eFlag flag_) {
-	flag.set(flag_);
-}
-
-void Univers::unsetFlag(eFlag flag_) {
-	flag.reset(flag_);
-}
-
-
-bool Univers::testFlag(eFlag flag_) {
-	return (flag.test(flag_));
-}
-
 /** Error **/
 
 bool Univers::dlError(char const *from) {
@@ -637,7 +654,8 @@
 	cleanAll();
 	clientTCP_ = nullptr;
 	serverTCP_ = nullptr;
-	unload_external_library();
+	unload_external_display_library();
+	unload_external_sound_library();
 	log_warn("~Univers.end()");
 }
 
