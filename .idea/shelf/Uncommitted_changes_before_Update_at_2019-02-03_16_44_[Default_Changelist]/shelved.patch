Index: dynamicLibrariesSources/display_glfw/src/main.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"DisplayGlfw.hpp\"\n#include \"Shader.hpp\"\n\n#include <glm/glm.hpp>\n#include <glm/gtc/type_ptr.hpp>\n\n\n#include <glad/glad.h>\n#include <GLFW/glfw3.h>\n#include <cstdio>\n#include <cstdlib>\n\n#include \"Glfw.hpp\"\n#include \"Model.hpp\"\n#include \"Mesh.hpp\"\n#include \"Camera.hpp\"\n#include <fstream>\n#include <MutantGrid.tpp>\nint main(int argc, char **argv) {\n\ttry {\n\t\tDisplayGlfw lol(35, 35, \"Issou\");\n\n\t\tMutantGrid< eSprite > background(35);\n\t\tMutantGrid< eSprite > al(35);\n\n\t\tbackground.fill(eSprite::GROUND);\n\n\t\tal.fill(eSprite::NONE);\n\n\t\tal(0, 0) = eSprite::FOOD;\n\t\tal(1, 1) = eSprite::WALL;\n\t\tal(3, 3) = (eSprite::BODY | eSprite::BLUE | eSprite::EAST);\n\t\tal(4, 3) = (eSprite::HEAD | eSprite::GREEN | eSprite::WEST);\n\t\tal(5, 3) = (eSprite::HEAD | eSprite::PURPLE | eSprite::SOUTH);\n\t\tal(6, 3) = (eSprite::HEAD | eSprite::PINK | eSprite::NORTH);\n\t\tal(7, 3) = (eSprite::HEAD | eSprite::GREY);\n\t\tal(8, 3) = (eSprite::HEAD | eSprite::YELLOW);\n\t\tal(9, 3) = (eSprite::HEAD | eSprite::ORANGE);\n\t\tal(10, 3) = (eSprite::HEAD | eSprite::RED);\n\n\t\tal(9, 1) = (eSprite::WALL);\n\t\tal(1, 9) = eSprite::WALL;\n\n\n\t\tlol.setBackground(background);\n\n\t\tfloat deltaTime = 0.0f;\n\t\tfloat lastFrame = 0.0f;\n\n\n\n\t\tfloat dist = 0;\n\t\tfloat maxDist = 1.4f;\n\n\t\tfloat start = 0.f;\n\n\t\tfloat count = 0.f;\n\n\t\tbool f = true;\n\n\t\twhile (!lol.exit()) {\n\n\t\t\tfloat currentFrame = glfwGetTime();\n\t\t\tdeltaTime = currentFrame - lastFrame;\n\t\t\tlastFrame = currentFrame;\n\t\t\tdist += deltaTime;\n\t\t\tif (f) {\n\t\t\t\tf = false;\n\t\t\t} else {\n\t\t\t\tstart += deltaTime;\n\t\t\t}\n\n\n\t\t\tif (dist > maxDist) {\n\t\t\t\tdist = 0;\n\t\t\t}\n\n\t\t\t//std::cout << deltaTime << std::endl;\n\n\t\t\tlol.update(deltaTime);\n\t\t\tlol.drawGrid(al);\n\t\t\tlol.render(dist, maxDist);\n\n\t\t\tcount += 1.f;\n\n\n\t\t\tstd::cout << \"It took me \" << deltaTime << \" seconds.\" << std::endl;\n\t\t}\n\t\tstd::cout << \"Average \" << start << \" for \" << count << \" So : \" << (start / count) << \" seconds.\";\n\n\t} catch (std::exception const &e) {\n\t\tstd::cout << e.what() << std::endl;\n\t}\n\n/*\n\tfloat deltaTime = 0.0f;\n\tfloat lastFrame = 0.0f;\n\n\n\tbool second = true;\n\tfloat time = 0.f;\n\n\tmodel.translate(glm::vec3(0.f, 0.f, 0.5f));\n\n\tglm::vec3 nextDirection = glm::vec3(0.f, 1.f, 0.f);\n\tglm::vec3 currentDirection = glm::vec3(0.f, 1.f, 0.f);\n\n\twhile (!glfw.exit()) {\n\n\t\tfloat currentFrame = glfwGetTime();\n\t\tdeltaTime = currentFrame - lastFrame;\n\t\tlastFrame = currentFrame;\n\t\ttime += deltaTime;\n\t\tif (time > 1.f) {\n\t\t\ttime -= 1.f;\n\t\t\tsecond = true;\n\t\t\tcurrentDirection = nextDirection;\n\t\t}\n\n\t\tview = camera.getViewMatrix();\n\t\tm_model = model.getTransform();\n\n\t\tcamera.update();\n\t\tglfw.update();\n        glClearColor(0.25f, 0.25f, 0.25f, 1.0f);\n\t\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);\n\n\t\tshader.activate();\n\n\t\tif (glfwGetKey(glfw.getWindow(), GLFW_KEY_W) == GLFW_PRESS)\n\t\t\tcamera.processPosition(Camera::Movement::FORWARD, deltaTime);\n\t\tif (glfwGetKey(glfw.getWindow(), GLFW_KEY_S) == GLFW_PRESS)\n\t\t\tcamera.processPosition(Camera::Movement::BACKWARD, deltaTime);\n\t\tif (glfwGetKey(glfw.getWindow(), GLFW_KEY_A) == GLFW_PRESS)\n\t\t\tcamera.processPosition(Camera::Movement::LEFT, deltaTime);\n\t\tif (glfwGetKey(glfw.getWindow(), GLFW_KEY_D) == GLFW_PRESS)\n\t\t\tcamera.processPosition(Camera::Movement::RIGHT, deltaTime);\n\t\tif (glfwGetKey(glfw.getWindow(), GLFW_KEY_F) == GLFW_PRESS) {\n\t\t}\n\n\t\tif (glfwGetKey(glfw.getWindow(), GLFW_KEY_I) == GLFW_PRESS)\n\t\t\tmodel.translate(glm::vec3(0.f, 0.f, 1.f) * deltaTime);\n\t\tif (glfwGetKey(glfw.getWindow(), GLFW_KEY_K) == GLFW_PRESS)\n\t\t\tmodel.translate(glm::vec3(0.f, 0.f, -1.f) * deltaTime);\n\t\tif (glfwGetKey(glfw.getWindow(), GLFW_KEY_J) == GLFW_PRESS)\n\t\t\tmodel.translate(glm::vec3(1.f, 0.f, 0.f) * deltaTime);\n\t\tif (glfwGetKey(glfw.getWindow(), GLFW_KEY_L) == GLFW_PRESS)\n\t\t\tmodel.translate(glm::vec3(-1.f, 0.f, 0.f) * deltaTime);\n\n\t\tif (glfwGetKey(glfw.getWindow(), GLFW_KEY_T) == GLFW_PRESS)\n\t\t\tmodel.rotate(glm::vec3(1.f, 0.f, 0.f), deltaTime);\n\t\tif (glfwGetKey(glfw.getWindow(), GLFW_KEY_G) == GLFW_PRESS)\n\t\t\tmodel.rotate(glm::vec3(0.f, 1.f, 0.f), deltaTime);\n\t\tif (glfwGetKey(glfw.getWindow(), GLFW_KEY_B) == GLFW_PRESS)\n\t\t\tmodel.rotate(glm::vec3(0.f, 0.f, 1.f), deltaTime);\n\n\n\t\tif (glfwGetKey(glfw.getWindow(), GLFW_KEY_KP_8) == GLFW_PRESS) {\n\t\t\tnextDirection = glm::vec3(0.f, 1.f, 0.f);\n\t\t}\n\t\tif (glfwGetKey(glfw.getWindow(), GLFW_KEY_KP_5) == GLFW_PRESS) {\n\t\t\tnextDirection = glm::vec3(0.f, -1.f, 0.f);\n\t\t}\n\t\tif (glfwGetKey(glfw.getWindow(), GLFW_KEY_KP_4) == GLFW_PRESS) {\n\t\t\tnextDirection = glm::vec3(-1.f, 0.f, 0.f);\n\t\t}\n\t\tif (glfwGetKey(glfw.getWindow(), GLFW_KEY_KP_6) == GLFW_PRESS) {\n\t\t\tnextDirection = glm::vec3(1.f, 0.f, 0.f);\n\t\t}\n\n\t\tmodel.translate(currentDirection * deltaTime);\n\n\n\n\t\tm_model = model.getTransform();\n\n\n\n\t\tshader.setMat4(\"projection\", projection);\n\t\tshader.setMat4(\"view\", view);\n\t\tshader.setMat4(\"model\", m_model);\n\t\tmodel.render(shader);\n\n\t\tfor (int y = -25; y < 25; y++) {\n\t\t\tfor (int x = -25; x < 25; x++) {\n\t\t\t\tblock.resetTransform();\n\t\t\t\tblock.translate(glm::vec3(x, y, 0.f));\n\t\t\t\tblock.scale(glm::vec3(-0.10f));\n\t\t\t\tm_model = block.getTransform();\n\t\t\t\tshader.setMat4(\"model\", m_model);\n\n\t\t\t\tblock.render(shader);\n\t\t\t}\n\t\t}\n\n        glfw.render();\n    }*/\n\n    return (0);\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- dynamicLibrariesSources/display_glfw/src/main.cpp	(date 1549205473000)
+++ dynamicLibrariesSources/display_glfw/src/main.cpp	(date 1549206670000)
@@ -84,118 +84,14 @@
 			count += 1.f;
 
 
-			std::cout << "It took me " << deltaTime << " seconds." << std::endl;
+			//std::cout << "It took me " << deltaTime << " seconds." << std::endl;
 		}
-		std::cout << "Average " << start << " for " << count << " So : " << (start / count) << " seconds.";
+		std::cout << "Average " << start << " for " << count << " So : " << (start / count) << " seconds." << std::endl;
 
 	} catch (std::exception const &e) {
 		std::cout << e.what() << std::endl;
 	}
 
-/*
-	float deltaTime = 0.0f;
-	float lastFrame = 0.0f;
-
-
-	bool second = true;
-	float time = 0.f;
-
-	model.translate(glm::vec3(0.f, 0.f, 0.5f));
-
-	glm::vec3 nextDirection = glm::vec3(0.f, 1.f, 0.f);
-	glm::vec3 currentDirection = glm::vec3(0.f, 1.f, 0.f);
-
-	while (!glfw.exit()) {
-
-		float currentFrame = glfwGetTime();
-		deltaTime = currentFrame - lastFrame;
-		lastFrame = currentFrame;
-		time += deltaTime;
-		if (time > 1.f) {
-			time -= 1.f;
-			second = true;
-			currentDirection = nextDirection;
-		}
-
-		view = camera.getViewMatrix();
-		m_model = model.getTransform();
-
-		camera.update();
-		glfw.update();
-        glClearColor(0.25f, 0.25f, 0.25f, 1.0f);
-		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);
-
-		shader.activate();
-
-		if (glfwGetKey(glfw.getWindow(), GLFW_KEY_W) == GLFW_PRESS)
-			camera.processPosition(Camera::Movement::FORWARD, deltaTime);
-		if (glfwGetKey(glfw.getWindow(), GLFW_KEY_S) == GLFW_PRESS)
-			camera.processPosition(Camera::Movement::BACKWARD, deltaTime);
-		if (glfwGetKey(glfw.getWindow(), GLFW_KEY_A) == GLFW_PRESS)
-			camera.processPosition(Camera::Movement::LEFT, deltaTime);
-		if (glfwGetKey(glfw.getWindow(), GLFW_KEY_D) == GLFW_PRESS)
-			camera.processPosition(Camera::Movement::RIGHT, deltaTime);
-		if (glfwGetKey(glfw.getWindow(), GLFW_KEY_F) == GLFW_PRESS) {
-		}
-
-		if (glfwGetKey(glfw.getWindow(), GLFW_KEY_I) == GLFW_PRESS)
-			model.translate(glm::vec3(0.f, 0.f, 1.f) * deltaTime);
-		if (glfwGetKey(glfw.getWindow(), GLFW_KEY_K) == GLFW_PRESS)
-			model.translate(glm::vec3(0.f, 0.f, -1.f) * deltaTime);
-		if (glfwGetKey(glfw.getWindow(), GLFW_KEY_J) == GLFW_PRESS)
-			model.translate(glm::vec3(1.f, 0.f, 0.f) * deltaTime);
-		if (glfwGetKey(glfw.getWindow(), GLFW_KEY_L) == GLFW_PRESS)
-			model.translate(glm::vec3(-1.f, 0.f, 0.f) * deltaTime);
-
-		if (glfwGetKey(glfw.getWindow(), GLFW_KEY_T) == GLFW_PRESS)
-			model.rotate(glm::vec3(1.f, 0.f, 0.f), deltaTime);
-		if (glfwGetKey(glfw.getWindow(), GLFW_KEY_G) == GLFW_PRESS)
-			model.rotate(glm::vec3(0.f, 1.f, 0.f), deltaTime);
-		if (glfwGetKey(glfw.getWindow(), GLFW_KEY_B) == GLFW_PRESS)
-			model.rotate(glm::vec3(0.f, 0.f, 1.f), deltaTime);
-
-
-		if (glfwGetKey(glfw.getWindow(), GLFW_KEY_KP_8) == GLFW_PRESS) {
-			nextDirection = glm::vec3(0.f, 1.f, 0.f);
-		}
-		if (glfwGetKey(glfw.getWindow(), GLFW_KEY_KP_5) == GLFW_PRESS) {
-			nextDirection = glm::vec3(0.f, -1.f, 0.f);
-		}
-		if (glfwGetKey(glfw.getWindow(), GLFW_KEY_KP_4) == GLFW_PRESS) {
-			nextDirection = glm::vec3(-1.f, 0.f, 0.f);
-		}
-		if (glfwGetKey(glfw.getWindow(), GLFW_KEY_KP_6) == GLFW_PRESS) {
-			nextDirection = glm::vec3(1.f, 0.f, 0.f);
-		}
-
-		model.translate(currentDirection * deltaTime);
-
-
-
-		m_model = model.getTransform();
-
-
-
-		shader.setMat4("projection", projection);
-		shader.setMat4("view", view);
-		shader.setMat4("model", m_model);
-		model.render(shader);
-
-		for (int y = -25; y < 25; y++) {
-			for (int x = -25; x < 25; x++) {
-				block.resetTransform();
-				block.translate(glm::vec3(x, y, 0.f));
-				block.scale(glm::vec3(-0.10f));
-				m_model = block.getTransform();
-				shader.setMat4("model", m_model);
-
-				block.render(shader);
-			}
-		}
-
-        glfw.render();
-    }*/
-
     return (0);
 
 }
\ No newline at end of file
Index: dynamicLibrariesSources/display_glfw/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>cmake_minimum_required(VERSION 3.0)\nset(NAME display_glfw)\nproject(${NAME})\n\n#add_definitions(-DGLFW_INCLUDE_NONE -DPROJECT_SOURCE_DIR=\\\"${PROJECT_SOURCE_DIR}\\\")\n#add_executable(${NAME}\n#        src/ActModel.cpp\n#        src/ActModel.hpp\n#        src/Camera.cpp\n#        src/Camera.hpp\n#        src/DisplayGlfw.cpp\n#        src/DisplayGlfw.hpp\n#        src/Glfw.cpp\n#        src/Glfw.hpp\n#        src/Light.cpp\n#        src/Light.hpp\n#        src/Material.cpp\n#        src/Material.hpp\n#        src/Mesh.cpp\n#        src/Mesh.hpp\n#        src/Model.cpp\n#        src/Model.hpp\n#        src/Particle.cpp\n#        src/Particle.hpp\n#        src/Shader.cpp\n#        src/Shader.hpp\n#        src/Skybox.cpp\n#        src/Skybox.hpp\n#        src/main.cpp\n#        )\n\nadd_library(${NAME} MODULE\n        ../../extern/glad/src/glad.c\n       src/ActModel.cpp\n       src/ActModel.hpp\n       src/Camera.cpp\n       src/Camera.hpp\n       src/DisplayGlfw.cpp\n       src/DisplayGlfw.hpp\n       src/Glfw.cpp\n       src/Glfw.hpp\n       src/Light.cpp\n       src/Light.hpp\n       src/Material.cpp\n       src/Material.hpp\n       src/Mesh.cpp\n       src/Mesh.hpp\n       src/Model.cpp\n       src/Model.hpp\n       src/Particle.cpp\n       src/Particle.hpp\n       src/Shader.cpp\n       src/Shader.hpp\n       src/Skybox.cpp\n       src/Skybox.hpp\n)\n\nset_target_properties(${NAME}\n        PROPERTIES\n        LIBRARY_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/dynamicLibraries\"\n        RUNTIME_OUTPUT_DIRECTORY \"${CMAKE_BINARY_DIR}/tmp\")\n\ntarget_link_libraries(${NAME} assimp glfw Boost::filesystem\n        ${GLFW_LIBRARIES} ${GLAD_LIBRARIES})\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- dynamicLibrariesSources/display_glfw/CMakeLists.txt	(date 1549205473000)
+++ dynamicLibrariesSources/display_glfw/CMakeLists.txt	(date 1549205969000)
@@ -3,33 +3,8 @@
 project(${NAME})
 
 #add_definitions(-DGLFW_INCLUDE_NONE -DPROJECT_SOURCE_DIR=\"${PROJECT_SOURCE_DIR}\")
-#add_executable(${NAME}
-#        src/ActModel.cpp
-#        src/ActModel.hpp
-#        src/Camera.cpp
-#        src/Camera.hpp
-#        src/DisplayGlfw.cpp
-#        src/DisplayGlfw.hpp
-#        src/Glfw.cpp
-#        src/Glfw.hpp
-#        src/Light.cpp
-#        src/Light.hpp
-#        src/Material.cpp
-#        src/Material.hpp
-#        src/Mesh.cpp
-#        src/Mesh.hpp
-#        src/Model.cpp
-#        src/Model.hpp
-#        src/Particle.cpp
-#        src/Particle.hpp
-#        src/Shader.cpp
-#        src/Shader.hpp
-#        src/Skybox.cpp
-#        src/Skybox.hpp
-#        src/main.cpp
-#        )
-
-add_library(${NAME} MODULE
+add_executable(${NAME} src/main.cpp
+#add_library(${NAME} MODULE
         ../../extern/glad/src/glad.c
        src/ActModel.cpp
        src/ActModel.hpp
Index: dynamicLibrariesSources/display_glfw/src/Glfw.cpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#include \"Glfw.hpp\"\n#include <iostream>\n\nGlfw::Glfw(std::string const &name, uint16_t width, uint16_t height) :\n    cursor_(true) {\n    std::cout << \"Glfw\" << std::endl;\n    glfwSetErrorCallback(Glfw::callbackError_);\n    glfwInit();\n    std::cout << \"glfwInit\" << std::endl;\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n    #ifdef __APPLE__\n        glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n    #endif\n    glfwWindowHint(GLFW_RESIZABLE, GL_FALSE);\n    std::cout << \"glfwWindowHint\" << std::endl;\n    if (!(window_ = glfwCreateWindow(width, height, name.c_str(), nullptr, nullptr))) {\n\t\tstd::cout << \"ERR\" << std::endl;\n        clean_();\n\t\tstd::cout << \"ERR\" << std::endl;\n\t\tthrow (Glfw::ConstructorException(\"GlfwConstructorException: window was not created\"));\n    }\n    std::cout << \"glfwCreateWindow\" << std::endl;\n\n    glfwMakeContextCurrent(window_);\n    std::cout << \"glfwMakeContextCurrent\" << std::endl;\n    gladLoadGLLoader((GLADloadproc)glfwGetProcAddress);\n    std::cout << \"OpenGL \" << glGetString(GL_VERSION) << std::endl;\n    glfwSwapInterval(0);\n\n\tglfwSetKeyCallback(window_, Glfw::callbackKey_);\n\n    Glfw::glfwByWindow_.insert(std::pair<GLFWwindow*, Glfw&>(window_, *this));\n}\n\nGlfw::~Glfw() {\n    for (auto it = Glfw::glfwByWindow_.begin(); it != Glfw::glfwByWindow_.end(); it++) {\n        if (&it->second == this)\n            Glfw::glfwByWindow_.erase(it);\n    }\n    clean_();\n}\n\nvoid    Glfw::clean_() {\n    glfwSetInputMode(window_, GLFW_CURSOR, GLFW_CURSOR_NORMAL);\n    glfwTerminate();\n}\n\neKeyState       Glfw::getKeyStateOf_(int key, std::map<int, eKeyState> const &keyState_) {\n    for (auto keyState : keyState_) {\n        if (keyState.first == key)\n            return (keyState.second);\n    }\n    return (eKeyState::kNone);\n}\neKeyState       Glfw::getKeyState(int key) const {\n    for (auto keyState : keyCurrent_) {\n        if (keyState.first == key)\n            return (keyState.second);\n    }\n    return (eKeyState::kNone);\n}\n\nvoid\t\t\tGlfw::callbackKey_(GLFWwindow* window, int key, int scancode, int action, int mods) {\n    for (auto &glfw : Glfw::glfwByWindow_) {\n        if (glfw.first == window) {\n            eKeyState pastKeyState = Glfw::getKeyStateOf_(key, glfw.second.keyPast_);\n            if (scancode == GLFW_REPEAT)\n                glfw.second.keyCurrent_.insert(std::pair<int, eKeyState >(key, eKeyState::kPress));\n            else if (scancode == GLFW_RELEASE)\n                glfw.second.keyCurrent_.insert(std::pair<int, eKeyState >(key, eKeyState::kRelease));\n            else if (pastKeyState == eKeyState::kDown && scancode == GLFW_PRESS)\n                glfw.second.keyCurrent_.insert(std::pair<int, eKeyState >(key, eKeyState::kPress));\n            else if (pastKeyState == eKeyState::kNone && scancode == GLFW_PRESS)\n                glfw.second.keyCurrent_.insert(std::pair<int, eKeyState >(key, eKeyState::kDown));\n        }\n    }\n}\nvoid Glfw::callbackError_(int error, const char* errorMessage) {\n    throw (Glfw::ConstructorException(errorMessage));\n}\n\nvoid            Glfw::update() {\n    if (glfwGetKey(window_, GLFW_KEY_ESCAPE) == GLFW_PRESS)\n        glfwSetWindowShouldClose(window_, true);\n    if (glfwGetKey(window_, GLFW_KEY_SPACE) == GLFW_PRESS) {\n        if (cursor_)\n            glfwSetInputMode(window_, GLFW_CURSOR, GLFW_CURSOR_DISABLED);\n        else\n            glfwSetInputMode(window_, GLFW_CURSOR, GLFW_CURSOR_NORMAL);\n        cursor_ = !cursor_;\n    }\n    keyPast_ = keyCurrent_;\n    keyCurrent_.clear();\n}\n\nvoid            Glfw::render() {\n    glfwSwapBuffers(window_);\n    glfwPollEvents();\n}\n\nbool            Glfw::exit() const {\n    return static_cast<bool>(glfwWindowShouldClose(window_));\n}\n\nGLFWwindow     *Glfw::getWindow() const {\n    return (window_);\n}\n\nstd::map<GLFWwindow*, Glfw&>     Glfw::glfwByWindow_;\n\nGlfw::ConstructorException::~ConstructorException(void) throw(){}\nGlfw::ConstructorException::ConstructorException(void) throw() :\n        _error(\"Error on Glfw constructor\") {}\nGlfw::ConstructorException::ConstructorException(std::string s) throw() :\n        _error(s) { }\nGlfw::ConstructorException::ConstructorException(Glfw::ConstructorException const &src) throw() :\n        _error(src._error)\n{ this->_error = src._error; }\nconst char\t*Glfw::ConstructorException::what() const throw()\n{ return (this->_error.c_str()); }
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- dynamicLibrariesSources/display_glfw/src/Glfw.cpp	(date 1549205473000)
+++ dynamicLibrariesSources/display_glfw/src/Glfw.cpp	(date 1549208680000)
@@ -35,10 +35,7 @@
 }
 
 Glfw::~Glfw() {
-    for (auto it = Glfw::glfwByWindow_.begin(); it != Glfw::glfwByWindow_.end(); it++) {
-        if (&it->second == this)
-            Glfw::glfwByWindow_.erase(it);
-    }
+    Glfw::glfwByWindow_.erase(Glfw::glfwByWindow_.find(window_));
     clean_();
 }
 
@@ -66,13 +63,13 @@
     for (auto &glfw : Glfw::glfwByWindow_) {
         if (glfw.first == window) {
             eKeyState pastKeyState = Glfw::getKeyStateOf_(key, glfw.second.keyPast_);
-            if (scancode == GLFW_REPEAT)
+            if (action == GLFW_REPEAT)
                 glfw.second.keyCurrent_.insert(std::pair<int, eKeyState >(key, eKeyState::kPress));
-            else if (scancode == GLFW_RELEASE)
-                glfw.second.keyCurrent_.insert(std::pair<int, eKeyState >(key, eKeyState::kRelease));
-            else if (pastKeyState == eKeyState::kDown && scancode == GLFW_PRESS)
+            else if (action == GLFW_RELEASE)
+                glfw.second.keyCurrent_.insert(std::pair<int, eKeyState >(key, eKeyState::kUp));
+            else if (pastKeyState == eKeyState::kDown && action == GLFW_PRESS)
                 glfw.second.keyCurrent_.insert(std::pair<int, eKeyState >(key, eKeyState::kPress));
-            else if (pastKeyState == eKeyState::kNone && scancode == GLFW_PRESS)
+            else if (pastKeyState == eKeyState::kNone && action == GLFW_PRESS)
                 glfw.second.keyCurrent_.insert(std::pair<int, eKeyState >(key, eKeyState::kDown));
         }
     }
@@ -82,16 +79,16 @@
 }
 
 void            Glfw::update() {
-    if (glfwGetKey(window_, GLFW_KEY_ESCAPE) == GLFW_PRESS)
+    if (getKeyState(GLFW_KEY_ESCAPE) == eKeyState::kDown)
         glfwSetWindowShouldClose(window_, true);
-    if (glfwGetKey(window_, GLFW_KEY_SPACE) == GLFW_PRESS) {
+    if (getKeyState(GLFW_KEY_SPACE) == eKeyState::kDown) {
         if (cursor_)
             glfwSetInputMode(window_, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
         else
             glfwSetInputMode(window_, GLFW_CURSOR, GLFW_CURSOR_NORMAL);
         cursor_ = !cursor_;
     }
-    keyPast_ = keyCurrent_;
+	keyPast_ = keyCurrent_;
     keyCurrent_.clear();
 }
 
Index: nibblerSources/incs/Sprite.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#ifndef NIBBLER_SPRITE_HPP\n#define NIBBLER_SPRITE_HPP\n\n#include <iostream>\n\nenum class eSprite {\n\tNONE = 0,\n\n\tGREEN = 1,\n\tBLUE = 2,\n\tPURPLE = 3,\n\tPINK = 4,\n\tGREY = 5,\n\tYELLOW = 6,\n\tORANGE = 7,\n\tRED = 8,\n\n\tMASK_COLOR = 0xFF,\n\n\tHEAD = (1 << 8),\n\tBODY = (1 << 9),\n\tTAIL = (1 << 10),\n\n\tMASK_BODY = HEAD | BODY | TAIL,\n\n\tNORTH = (1 << 11),\n\tSOUTH = (1 << 12),\n\tEAST = (1 << 13),\n\tWEST = (1 << 14),\n\n\tMASK_DIRECTION = NORTH | SOUTH | EAST | WEST,\n\n\tFROM_NORTH = (1 << 15),\n\tFROM_SOUTH = (1 << 16),\n\tFROM_EAST = (1 << 17),\n\tFROM_WEST = (1 << 18),\n\n\tMASK_FROM = FROM_NORTH | FROM_SOUTH | FROM_EAST | FROM_WEST,\n\n\tTO_NORTH = (1 << 19),\n\tTO_SOUTH = (1 << 20),\n\tTO_EAST = (1 << 21),\n\tTO_WEST = (1 << 22),\n\n\tMASK_TO = TO_NORTH | TO_SOUTH | TO_EAST | TO_WEST,\n\n\tBITWISE_TO = 8,\n\tBITWISE_FROM = 4,\n\n\n\tWALL = (1 << 23),\n\tFOOD = (1 << 24),\n\tGROUND = (1 << 25),\n\n\tYOUR_SNAKE = (1 << 30)\n};\n\ninline bool operator==(eSprite const lhs, eSprite const rhs) {\n\treturn static_cast<int>(lhs) == static_cast<int>(rhs);\n}\n\ninline eSprite operator|(eSprite const lhs, eSprite const rhs) {\n\treturn static_cast<eSprite> (static_cast<int>(lhs) | static_cast<int>(rhs));\n}\n\ninline eSprite const &operator|=(eSprite &lhs, eSprite const &rhs) {\n\tlhs = static_cast<eSprite> (static_cast<int>(lhs) | static_cast<int>(rhs));\n\treturn (lhs);\n}\ninline eSprite operator&(eSprite const lhs, eSprite const rhs) {\n\treturn static_cast<eSprite> (static_cast<int>(lhs) &  static_cast<int>(rhs));\n}\ninline eSprite operator&(int const lhs, eSprite const rhs) {\n\treturn static_cast<eSprite> (lhs &  static_cast<int>(rhs));\n}\ninline eSprite operator&(eSprite const lhs, int const rhs) {\n\treturn static_cast<eSprite> (static_cast<int>(lhs) & rhs);\n}\ninline eSprite operator^(int const lhs, eSprite const rhs) {\n\treturn static_cast<eSprite> (lhs ^  static_cast<int>(rhs));\n}\ninline eSprite operator^(eSprite const lhs, int const rhs) {\n\treturn static_cast<eSprite> (static_cast<int>(lhs) ^ rhs);\n}\ninline eSprite operator<<(eSprite const lhs, eSprite const rhs) {\n\treturn static_cast<eSprite> (static_cast<int>(lhs) << static_cast<int>(rhs));\n}\ninline eSprite operator>>(eSprite const lhs, eSprite const rhs) {\n\treturn static_cast<eSprite> (static_cast<int>(lhs) >> static_cast<int>(rhs));\n}\ninline std::ostream &operator<<(std::ostream &os, eSprite &sprite) {\n\tswitch (sprite) {\n\t\tcase eSprite ::GREEN :\n\t\t\tos << \"GREEN\";\n\t\t\tbreak;\n\t\tcase eSprite ::BLUE :\n\t\t\tos << \"BLUE\";\n\t\t\tbreak;\n\t\tcase eSprite ::PURPLE :\n\t\t\tos << \"PURPLE\";\n\t\t\tbreak;\n\t\tcase eSprite ::PINK :\n\t\t\tos << \"PINK\";\n\t\t\tbreak;\n\t\tcase eSprite ::GREY :\n\t\t\tos << \"GREY\";\n\t\t\tbreak;\n\t\tcase eSprite ::YELLOW :\n\t\t\tos << \"YELLOW\";\n\t\t\tbreak;\n\t\tcase eSprite ::ORANGE :\n\t\t\tos << \"ORANGE\";\n\t\t\tbreak;\n\t\tcase eSprite ::RED :\n\t\t\tos << \"RED\";\n\t\t\tbreak;\n\t\tdefault :\n\t\t\tbreak;\n\t}\n\n\tif ((sprite & eSprite::HEAD) == eSprite::HEAD)\n\t\tos << \"Head\";\n\telse if ((sprite & eSprite::TAIL) == eSprite::TAIL)\n\t\tos << \"Tail\";\n\telse if ((sprite & eSprite::BODY) == eSprite::BODY)\n\t\tos << \"Body\";\n\telse if ((sprite & eSprite::WALL) == eSprite::WALL)\n\t\tos << \"WALL\";\n\telse if ((sprite & eSprite::FOOD) == eSprite::FOOD)\n\t\tos << \"OOOO\";\n\telse if ((sprite & eSprite::NONE) == eSprite::NONE)\n\t\tos << \"-N-\";\n\telse\n\t\tos << static_cast<int>(sprite);\n\treturn os;\n}\n\n#endif //NIBBLER_SPRITE_HPP\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- nibblerSources/incs/Sprite.hpp	(date 1549205473000)
+++ nibblerSources/incs/Sprite.hpp	(date 1549208286000)
@@ -55,14 +55,9 @@
 	YOUR_SNAKE = (1 << 30)
 };
 
-inline bool operator==(eSprite const lhs, eSprite const rhs) {
-	return static_cast<int>(lhs) == static_cast<int>(rhs);
-}
-
 inline eSprite operator|(eSprite const lhs, eSprite const rhs) {
 	return static_cast<eSprite> (static_cast<int>(lhs) | static_cast<int>(rhs));
 }
-
 inline eSprite const &operator|=(eSprite &lhs, eSprite const &rhs) {
 	lhs = static_cast<eSprite> (static_cast<int>(lhs) | static_cast<int>(rhs));
 	return (lhs);
Index: dynamicLibrariesSources/display_glfw/src/Glfw.hpp
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>#pragma once\n\n#include <memory>\n#include <string>\n#include <map>\n#include <glad/glad.h>\n#include <GLFW/glfw3.h>\n#include <cstdint>\n\nenum class eKeyState { kNone, kDown, kPress, kRelease };\n\ninline bool operator!(eKeyState keyState) {\n    return (keyState == eKeyState::kNone);\n}\n\nclass Glfw {\npublic:\n    class ConstructorException : public std::exception {\n    public:\n        ConstructorException(void) throw();\n        ConstructorException(std::string) throw();\n        virtual const char* what() const throw();\n        ~ConstructorException(void) throw();\n        ConstructorException(ConstructorException const &src) throw();\n    private:\n        ConstructorException &operator=(ConstructorException const &rhs) throw();\n        std::string\t\t\t_error;\n    };\n\n    Glfw(std::string const &name, uint16_t width, uint16_t height);\n    ~Glfw();\n\n    void            update();\n    void            render();\n    bool            exit() const;\n\n    GLFWwindow     *getWindow() const;\n\nprotected:\n    bool                        cursor_;\n\nprivate:\n    GLFWwindow                  *window_;\n\n    std::map<int, eKeyState> keyCurrent_;\n    std::map<int, eKeyState> keyPast_;\n\n    void            clean_();\n    eKeyState       getKeyState(int key) const;\n\n    static eKeyState       getKeyStateOf_(int key, std::map<int, eKeyState> const &keyState_);\n    static void            callbackKey_(GLFWwindow* window, int key, int scancode, int action, int mods);\n    static void            callbackError_(int error, const char* errorMessage);\n    static std::map<GLFWwindow*, Glfw&>     glfwByWindow_;\n\n    Glfw(Glfw const &shader) = delete;\n    Glfw &operator=(Glfw const &shader) = delete;\n};
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- dynamicLibrariesSources/display_glfw/src/Glfw.hpp	(date 1549205473000)
+++ dynamicLibrariesSources/display_glfw/src/Glfw.hpp	(date 1549208680000)
@@ -7,11 +7,35 @@
 #include <GLFW/glfw3.h>
 #include <cstdint>
 
-enum class eKeyState { kNone, kDown, kPress, kRelease };
+enum class eKeyState {
+    kNone = (1 << 0),
+    kDown = (1 << 1),
+    kPress = (1 << 2),
+    kUp = (1 << 3)
+};
 
 inline bool operator!(eKeyState keyState) {
     return (keyState == eKeyState::kNone);
 }
+inline eKeyState operator|(eKeyState const lhs, eKeyState const rhs) {
+    return static_cast<eKeyState> (static_cast<int>(lhs) | static_cast<int>(rhs));
+}
+inline eKeyState const &operator|=(eKeyState &lhs, eKeyState const &rhs) {
+    lhs = static_cast<eKeyState> (static_cast<int>(lhs) | static_cast<int>(rhs));
+    return (lhs);
+}
+inline eKeyState operator&(eKeyState const lhs, eKeyState const rhs) {
+    return static_cast<eKeyState> (static_cast<int>(lhs) &  static_cast<int>(rhs));
+}
+inline eKeyState operator^(eKeyState const lhs, eKeyState const rhs) {
+    return static_cast<eKeyState> (static_cast<int>(lhs) ^ static_cast<int>(rhs));
+}
+inline eKeyState operator<<(eKeyState const lhs, eKeyState const rhs) {
+    return static_cast<eKeyState> (static_cast<int>(lhs) << static_cast<int>(rhs));
+}
+inline eKeyState operator>>(eKeyState const lhs, eKeyState const rhs) {
+    return static_cast<eKeyState> (static_cast<int>(lhs) >> static_cast<int>(rhs));
+}
 
 class Glfw {
 public:
